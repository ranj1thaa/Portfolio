import { __commonJS, __toESM, require_react } from "./react-BaqBjuxQ.js";
import { require_react_dom } from "./react-dom-Cndd9GYP.js";
import { require_jsx_runtime } from "./jsx-runtime-DSm6idpZ.js";
import { DEFAULT_BREAKPOINTS, DEFAULT_MIN_BREAKPOINT, ThemeProvider_default, require_classnames, useBootstrapBreakpoints, useBootstrapMinBreakpoint, useBootstrapPrefix, useIsRTL } from "./ThemeProvider-BFaBPo6L.js";
import { NavbarContext_default, SelectableContext_default, dataAttr, makeEventKey, qsa, require_browser, useEventCallback as useEventCallback$1, useMergedRefs_default as useMergedRefs_default$1, useMounted, usePrevious, useUncontrolled, useUncontrolledProp as useUncontrolledProp$1 } from "./useMergedRefs-DiqteKKP.js";
import { AbstractModalHeader_default, CloseButton_default, Collapse_default, ENTERING, EXITING, Fade_default, ModalContext_default, Modal_default as Modal_default$1, NavbarBrand_default, NavbarCollapse_default, NavbarOffcanvas_default, NavbarText_default, NavbarToggle_default, Navbar_default, NoopTransition_default, OffcanvasBody_default, OffcanvasHeader_default, OffcanvasTitle_default, OffcanvasToggling_default, Offcanvas_default, TransitionWrapper_default, addEventListener_default, canUseDOM_default, contains, createChainedFunction_default, divWithClassName_default, getChildRef, getSharedManager, hasClass, isEscKey, listen_default, ownerDocument, removeEventListener_default, renderTransition, require_prop_types, safeFindDOMNode, transitionEnd, transitionEndListener, triggerBrowserReflow, useCommittedRef_default, useEventCallback, useIsomorphicEffect_default, useMergedRefs_default, useWaitForDOMRef, useWindow } from "./Navbar-BDRBwb8G.js";
import { Anchor_default as Anchor_default$1, Button_default as Button_default$1, CardHeaderContext_default, NavContext_default, NavItem_default, NavLink_default, Nav_default, Nav_default$1, TabContext_default, useButtonProps, useCallbackRef, useEventListener, useForceUpdate, useNavItem } from "./Nav-Bs7cnUN9.js";
import { Container_default } from "./Container-jYXtzY-Q.js";

//#region node_modules/react-bootstrap/esm/AccordionContext.js
var import_classnames$84 = /* @__PURE__ */ __toESM(require_classnames());
var import_react = /* @__PURE__ */ __toESM(require_react());
function isAccordionItemSelected(activeEventKey, eventKey) {
	return Array.isArray(activeEventKey) ? activeEventKey.includes(eventKey) : activeEventKey === eventKey;
}
var context$2 = /* @__PURE__ */ import_react.createContext({});
context$2.displayName = "AccordionContext";
var AccordionContext_default = context$2;

//#endregion
//#region node_modules/react-bootstrap/esm/AccordionCollapse.js
var import_jsx_runtime = /* @__PURE__ */ __toESM(require_jsx_runtime());
/**
* This component accepts all of [`Collapse`'s props](/docs/utilities/transitions#collapse-1).
*/
var AccordionCollapse = /* @__PURE__ */ import_react.forwardRef(({ as: Component = "div", bsPrefix, className, children, eventKey,...props }, ref) => {
	const { activeEventKey } = (0, import_react.useContext)(AccordionContext_default);
	bsPrefix = useBootstrapPrefix(bsPrefix, "accordion-collapse");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Collapse_default, {
		ref,
		in: isAccordionItemSelected(activeEventKey, eventKey),
		...props,
		className: (0, import_classnames$84.default)(className, bsPrefix),
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, { children: import_react.Children.only(children) })
	});
});
AccordionCollapse.displayName = "AccordionCollapse";
var AccordionCollapse_default = AccordionCollapse;

//#endregion
//#region node_modules/react-bootstrap/esm/AccordionItemContext.js
var context$1 = /* @__PURE__ */ import_react.createContext({ eventKey: "" });
context$1.displayName = "AccordionItemContext";
var AccordionItemContext_default = context$1;

//#endregion
//#region node_modules/react-bootstrap/esm/AccordionBody.js
var import_classnames$83 = /* @__PURE__ */ __toESM(require_classnames());
var AccordionBody = /* @__PURE__ */ import_react.forwardRef(({ as: Component = "div", bsPrefix, className, onEnter, onEntering, onEntered, onExit, onExiting, onExited,...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "accordion-body");
	const { eventKey } = (0, import_react.useContext)(AccordionItemContext_default);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(AccordionCollapse_default, {
		eventKey,
		onEnter,
		onEntering,
		onEntered,
		onExit,
		onExiting,
		onExited,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
			ref,
			...props,
			className: (0, import_classnames$83.default)(className, bsPrefix)
		})
	});
});
AccordionBody.displayName = "AccordionBody";
var AccordionBody_default = AccordionBody;

//#endregion
//#region node_modules/react-bootstrap/esm/AccordionButton.js
var import_classnames$82 = /* @__PURE__ */ __toESM(require_classnames());
function useAccordionButton(eventKey, onClick) {
	const { activeEventKey, onSelect, alwaysOpen } = (0, import_react.useContext)(AccordionContext_default);
	return (e) => {
		let eventKeyPassed = eventKey === activeEventKey ? null : eventKey;
		if (alwaysOpen) if (Array.isArray(activeEventKey)) if (activeEventKey.includes(eventKey)) eventKeyPassed = activeEventKey.filter((k) => k !== eventKey);
		else eventKeyPassed = [...activeEventKey, eventKey];
		else eventKeyPassed = [eventKey];
		onSelect?.(eventKeyPassed, e);
		onClick?.(e);
	};
}
var AccordionButton = /* @__PURE__ */ import_react.forwardRef(({ as: Component = "button", bsPrefix, className, onClick,...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "accordion-button");
	const { eventKey } = (0, import_react.useContext)(AccordionItemContext_default);
	const accordionOnClick = useAccordionButton(eventKey, onClick);
	const { activeEventKey } = (0, import_react.useContext)(AccordionContext_default);
	if (Component === "button") props.type = "button";
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		onClick: accordionOnClick,
		...props,
		"aria-expanded": Array.isArray(activeEventKey) ? activeEventKey.includes(eventKey) : eventKey === activeEventKey,
		className: (0, import_classnames$82.default)(className, bsPrefix, !isAccordionItemSelected(activeEventKey, eventKey) && "collapsed")
	});
});
AccordionButton.displayName = "AccordionButton";
var AccordionButton_default = AccordionButton;

//#endregion
//#region node_modules/react-bootstrap/esm/AccordionHeader.js
var import_classnames$81 = /* @__PURE__ */ __toESM(require_classnames());
var AccordionHeader = /* @__PURE__ */ import_react.forwardRef(({ as: Component = "h2", "aria-controls": ariaControls, bsPrefix, className, children, onClick,...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "accordion-header");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		...props,
		className: (0, import_classnames$81.default)(className, bsPrefix),
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(AccordionButton_default, {
			onClick,
			"aria-controls": ariaControls,
			children
		})
	});
});
AccordionHeader.displayName = "AccordionHeader";
var AccordionHeader_default = AccordionHeader;

//#endregion
//#region node_modules/react-bootstrap/esm/AccordionItem.js
var import_classnames$80 = /* @__PURE__ */ __toESM(require_classnames());
var AccordionItem = /* @__PURE__ */ import_react.forwardRef(({ as: Component = "div", bsPrefix, className, eventKey,...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "accordion-item");
	const contextValue = (0, import_react.useMemo)(() => ({ eventKey }), [eventKey]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(AccordionItemContext_default.Provider, {
		value: contextValue,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
			ref,
			...props,
			className: (0, import_classnames$80.default)(className, bsPrefix)
		})
	});
});
AccordionItem.displayName = "AccordionItem";
var AccordionItem_default = AccordionItem;

//#endregion
//#region node_modules/react-bootstrap/esm/Accordion.js
var import_classnames$79 = /* @__PURE__ */ __toESM(require_classnames());
var Accordion = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { as: Component = "div", activeKey, bsPrefix, className, onSelect, flush, alwaysOpen,...controlledProps } = useUncontrolled(props, { activeKey: "onSelect" });
	const prefix = useBootstrapPrefix(bsPrefix, "accordion");
	const contextValue = (0, import_react.useMemo)(() => ({
		activeEventKey: activeKey,
		onSelect,
		alwaysOpen
	}), [
		activeKey,
		onSelect,
		alwaysOpen
	]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(AccordionContext_default.Provider, {
		value: contextValue,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
			ref,
			...controlledProps,
			className: (0, import_classnames$79.default)(className, prefix, flush && `${prefix}-flush`)
		})
	});
});
Accordion.displayName = "Accordion";
var Accordion_default = Object.assign(Accordion, {
	Button: AccordionButton_default,
	Collapse: AccordionCollapse_default,
	Item: AccordionItem_default,
	Header: AccordionHeader_default,
	Body: AccordionBody_default
});

//#endregion
//#region node_modules/react-bootstrap/esm/AlertHeading.js
var import_classnames$78 = /* @__PURE__ */ __toESM(require_classnames());
var DivStyledAsH4$1 = divWithClassName_default("h4");
DivStyledAsH4$1.displayName = "DivStyledAsH4";
var AlertHeading = /* @__PURE__ */ import_react.forwardRef(({ className, bsPrefix, as: Component = DivStyledAsH4$1,...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "alert-heading");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		className: (0, import_classnames$78.default)(className, bsPrefix),
		...props
	});
});
AlertHeading.displayName = "AlertHeading";
var AlertHeading_default = AlertHeading;

//#endregion
//#region node_modules/react-bootstrap/esm/AlertLink.js
var import_classnames$77 = /* @__PURE__ */ __toESM(require_classnames());
var AlertLink = /* @__PURE__ */ import_react.forwardRef(({ className, bsPrefix, as: Component = Anchor_default$1,...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "alert-link");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		className: (0, import_classnames$77.default)(className, bsPrefix),
		...props
	});
});
AlertLink.displayName = "AlertLink";
var AlertLink_default = AlertLink;

//#endregion
//#region node_modules/react-bootstrap/esm/Alert.js
var import_classnames$76 = /* @__PURE__ */ __toESM(require_classnames());
var Alert = /* @__PURE__ */ import_react.forwardRef((uncontrolledProps, ref) => {
	const { bsPrefix, show = true, closeLabel = "Close alert", closeVariant, className, children, variant = "primary", onClose, dismissible, transition = Fade_default,...props } = useUncontrolled(uncontrolledProps, { show: "onClose" });
	const prefix = useBootstrapPrefix(bsPrefix, "alert");
	const handleClose = useEventCallback((e) => {
		if (onClose) onClose(false, e);
	});
	const Transition = transition === true ? Fade_default : transition;
	const alert = /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		role: "alert",
		...!Transition ? props : void 0,
		ref,
		className: (0, import_classnames$76.default)(className, prefix, variant && `${prefix}-${variant}`, dismissible && `${prefix}-dismissible`),
		children: [dismissible && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CloseButton_default, {
			onClick: handleClose,
			"aria-label": closeLabel,
			variant: closeVariant
		}), children]
	});
	if (!Transition) return show ? alert : null;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Transition, {
		unmountOnExit: true,
		...props,
		ref: void 0,
		in: show,
		children: alert
	});
});
Alert.displayName = "Alert";
var Alert_default = Object.assign(Alert, {
	Link: AlertLink_default,
	Heading: AlertHeading_default
});

//#endregion
//#region node_modules/react-bootstrap/esm/Anchor.js
var Anchor_default = Anchor_default$1;

//#endregion
//#region node_modules/react-bootstrap/esm/Badge.js
var import_classnames$75 = /* @__PURE__ */ __toESM(require_classnames());
var Badge = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, bg = "primary", pill = false, text, className, as: Component = "span",...props }, ref) => {
	const prefix = useBootstrapPrefix(bsPrefix, "badge");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		...props,
		className: (0, import_classnames$75.default)(className, prefix, pill && `rounded-pill`, text && `text-${text}`, bg && `bg-${bg}`)
	});
});
Badge.displayName = "Badge";
var Badge_default = Badge;

//#endregion
//#region node_modules/react-bootstrap/esm/BreadcrumbItem.js
var import_classnames$74 = /* @__PURE__ */ __toESM(require_classnames());
var BreadcrumbItem = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, active = false, children, className, as: Component = "li", linkAs: LinkComponent = Anchor_default$1, linkProps = {}, href, title, target,...props }, ref) => {
	const prefix = useBootstrapPrefix(bsPrefix, "breadcrumb-item");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		...props,
		className: (0, import_classnames$74.default)(prefix, className, { active }),
		"aria-current": active ? "page" : void 0,
		children: active ? children : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(LinkComponent, {
			...linkProps,
			href,
			title,
			target,
			children
		})
	});
});
BreadcrumbItem.displayName = "BreadcrumbItem";
var BreadcrumbItem_default = BreadcrumbItem;

//#endregion
//#region node_modules/react-bootstrap/esm/Breadcrumb.js
var import_classnames$73 = /* @__PURE__ */ __toESM(require_classnames());
var Breadcrumb = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, className, listProps = {}, children, label = "breadcrumb", as: Component = "nav",...props }, ref) => {
	const prefix = useBootstrapPrefix(bsPrefix, "breadcrumb");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		"aria-label": label,
		className,
		ref,
		...props,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("ol", {
			...listProps,
			className: (0, import_classnames$73.default)(prefix, listProps == null ? void 0 : listProps.className),
			children
		})
	});
});
Breadcrumb.displayName = "Breadcrumb";
var Breadcrumb_default = Object.assign(Breadcrumb, { Item: BreadcrumbItem_default });

//#endregion
//#region node_modules/react-bootstrap/esm/Button.js
var import_classnames$72 = /* @__PURE__ */ __toESM(require_classnames());
var Button = /* @__PURE__ */ import_react.forwardRef(({ as, bsPrefix, variant = "primary", size: size$1, active = false, disabled = false, className,...props }, ref) => {
	const prefix = useBootstrapPrefix(bsPrefix, "btn");
	const [buttonProps, { tagName }] = useButtonProps({
		tagName: as,
		disabled,
		...props
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(tagName, {
		...buttonProps,
		...props,
		ref,
		disabled,
		className: (0, import_classnames$72.default)(className, prefix, active && "active", variant && `${prefix}-${variant}`, size$1 && `${prefix}-${size$1}`, props.href && disabled && "disabled")
	});
});
Button.displayName = "Button";
var Button_default = Button;

//#endregion
//#region node_modules/react-bootstrap/esm/ButtonGroup.js
var import_classnames$71 = /* @__PURE__ */ __toESM(require_classnames());
var ButtonGroup = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, size: size$1, vertical = false, className, role = "group", as: Component = "div",...rest }, ref) => {
	const prefix = useBootstrapPrefix(bsPrefix, "btn-group");
	let baseClass = prefix;
	if (vertical) baseClass = `${prefix}-vertical`;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		...rest,
		ref,
		role,
		className: (0, import_classnames$71.default)(className, baseClass, size$1 && `${prefix}-${size$1}`)
	});
});
ButtonGroup.displayName = "ButtonGroup";
var ButtonGroup_default = ButtonGroup;

//#endregion
//#region node_modules/react-bootstrap/esm/ButtonToolbar.js
var import_classnames$70 = /* @__PURE__ */ __toESM(require_classnames());
var ButtonToolbar = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, className, role = "toolbar",...props }, ref) => {
	const prefix = useBootstrapPrefix(bsPrefix, "btn-toolbar");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		...props,
		ref,
		className: (0, import_classnames$70.default)(className, prefix),
		role
	});
});
ButtonToolbar.displayName = "ButtonToolbar";
var ButtonToolbar_default = ButtonToolbar;

//#endregion
//#region node_modules/react-bootstrap/esm/CardBody.js
var import_classnames$69 = /* @__PURE__ */ __toESM(require_classnames());
var CardBody = /* @__PURE__ */ import_react.forwardRef(({ className, bsPrefix, as: Component = "div",...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "card-body");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		className: (0, import_classnames$69.default)(className, bsPrefix),
		...props
	});
});
CardBody.displayName = "CardBody";
var CardBody_default = CardBody;

//#endregion
//#region node_modules/react-bootstrap/esm/CardFooter.js
var import_classnames$68 = /* @__PURE__ */ __toESM(require_classnames());
var CardFooter = /* @__PURE__ */ import_react.forwardRef(({ className, bsPrefix, as: Component = "div",...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "card-footer");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		className: (0, import_classnames$68.default)(className, bsPrefix),
		...props
	});
});
CardFooter.displayName = "CardFooter";
var CardFooter_default = CardFooter;

//#endregion
//#region node_modules/react-bootstrap/esm/CardHeader.js
var import_classnames$67 = /* @__PURE__ */ __toESM(require_classnames());
var CardHeader = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, className, as: Component = "div",...props }, ref) => {
	const prefix = useBootstrapPrefix(bsPrefix, "card-header");
	const contextValue = (0, import_react.useMemo)(() => ({ cardHeaderBsPrefix: prefix }), [prefix]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CardHeaderContext_default.Provider, {
		value: contextValue,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
			ref,
			...props,
			className: (0, import_classnames$67.default)(className, prefix)
		})
	});
});
CardHeader.displayName = "CardHeader";
var CardHeader_default = CardHeader;

//#endregion
//#region node_modules/react-bootstrap/esm/CardImg.js
var import_classnames$66 = /* @__PURE__ */ __toESM(require_classnames());
var CardImg = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, className, variant, as: Component = "img",...props }, ref) => {
	const prefix = useBootstrapPrefix(bsPrefix, "card-img");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		className: (0, import_classnames$66.default)(variant ? `${prefix}-${variant}` : prefix, className),
		...props
	});
});
CardImg.displayName = "CardImg";
var CardImg_default = CardImg;

//#endregion
//#region node_modules/react-bootstrap/esm/CardImgOverlay.js
var import_classnames$65 = /* @__PURE__ */ __toESM(require_classnames());
var CardImgOverlay = /* @__PURE__ */ import_react.forwardRef(({ className, bsPrefix, as: Component = "div",...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "card-img-overlay");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		className: (0, import_classnames$65.default)(className, bsPrefix),
		...props
	});
});
CardImgOverlay.displayName = "CardImgOverlay";
var CardImgOverlay_default = CardImgOverlay;

//#endregion
//#region node_modules/react-bootstrap/esm/CardLink.js
var import_classnames$64 = /* @__PURE__ */ __toESM(require_classnames());
var CardLink = /* @__PURE__ */ import_react.forwardRef(({ className, bsPrefix, as: Component = "a",...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "card-link");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		className: (0, import_classnames$64.default)(className, bsPrefix),
		...props
	});
});
CardLink.displayName = "CardLink";
var CardLink_default = CardLink;

//#endregion
//#region node_modules/react-bootstrap/esm/CardSubtitle.js
var import_classnames$63 = /* @__PURE__ */ __toESM(require_classnames());
var DivStyledAsH6 = divWithClassName_default("h6");
var CardSubtitle = /* @__PURE__ */ import_react.forwardRef(({ className, bsPrefix, as: Component = DivStyledAsH6,...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "card-subtitle");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		className: (0, import_classnames$63.default)(className, bsPrefix),
		...props
	});
});
CardSubtitle.displayName = "CardSubtitle";
var CardSubtitle_default = CardSubtitle;

//#endregion
//#region node_modules/react-bootstrap/esm/CardText.js
var import_classnames$62 = /* @__PURE__ */ __toESM(require_classnames());
var CardText = /* @__PURE__ */ import_react.forwardRef(({ className, bsPrefix, as: Component = "p",...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "card-text");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		className: (0, import_classnames$62.default)(className, bsPrefix),
		...props
	});
});
CardText.displayName = "CardText";
var CardText_default = CardText;

//#endregion
//#region node_modules/react-bootstrap/esm/CardTitle.js
var import_classnames$61 = /* @__PURE__ */ __toESM(require_classnames());
var DivStyledAsH5 = divWithClassName_default("h5");
var CardTitle = /* @__PURE__ */ import_react.forwardRef(({ className, bsPrefix, as: Component = DivStyledAsH5,...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "card-title");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		className: (0, import_classnames$61.default)(className, bsPrefix),
		...props
	});
});
CardTitle.displayName = "CardTitle";
var CardTitle_default = CardTitle;

//#endregion
//#region node_modules/react-bootstrap/esm/Card.js
var import_classnames$60 = /* @__PURE__ */ __toESM(require_classnames());
var Card = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, className, bg, text, border, body = false, children, as: Component = "div",...props }, ref) => {
	const prefix = useBootstrapPrefix(bsPrefix, "card");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		...props,
		className: (0, import_classnames$60.default)(className, prefix, bg && `bg-${bg}`, text && `text-${text}`, border && `border-${border}`),
		children: body ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CardBody_default, { children }) : children
	});
});
Card.displayName = "Card";
var Card_default = Object.assign(Card, {
	Img: CardImg_default,
	Title: CardTitle_default,
	Subtitle: CardSubtitle_default,
	Body: CardBody_default,
	Link: CardLink_default,
	Text: CardText_default,
	Header: CardHeader_default,
	Footer: CardFooter_default,
	ImgOverlay: CardImgOverlay_default
});

//#endregion
//#region node_modules/react-bootstrap/esm/CardGroup.js
var import_classnames$59 = /* @__PURE__ */ __toESM(require_classnames());
var CardGroup = /* @__PURE__ */ import_react.forwardRef(({ className, bsPrefix, as: Component = "div",...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "card-group");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		className: (0, import_classnames$59.default)(className, bsPrefix),
		...props
	});
});
CardGroup.displayName = "CardGroup";
var CardGroup_default = CardGroup;

//#endregion
//#region node_modules/@restart/hooks/esm/useUpdateEffect.js
/**
* Runs an effect only when the dependencies have changed, skipping the
* initial "on mount" run. Caution, if the dependency list never changes,
* the effect is **never run**
*
* ```ts
*  const ref = useRef<HTMLInput>(null);
*
*  // focuses an element only if the focus changes, and not on mount
*  useUpdateEffect(() => {
*    const element = ref.current?.children[focusedIdx] as HTMLElement
*
*    element?.focus()
*
*  }, [focusedIndex])
* ```
* @param effect An effect to run on mount
*
* @category effects
*/
function useUpdateEffect(fn, deps) {
	const isFirst = (0, import_react.useRef)(true);
	(0, import_react.useEffect)(() => {
		if (isFirst.current) {
			isFirst.current = false;
			return;
		}
		return fn();
	}, deps);
}
var useUpdateEffect_default = useUpdateEffect;

//#endregion
//#region node_modules/@restart/hooks/esm/useMounted.js
/**
* Track whether a component is current mounted. Generally less preferable than
* properlly canceling effects so they don't run after a component is unmounted,
* but helpful in cases where that isn't feasible, such as a `Promise` resolution.
*
* @returns a function that returns the current isMounted state of the component
*
* ```ts
* const [data, setData] = useState(null)
* const isMounted = useMounted()
*
* useEffect(() => {
*   fetchdata().then((newData) => {
*      if (isMounted()) {
*        setData(newData);
*      }
*   })
* })
* ```
*/
function useMounted$1() {
	const mounted = (0, import_react.useRef)(true);
	const isMounted = (0, import_react.useRef)(() => mounted.current);
	(0, import_react.useEffect)(() => {
		mounted.current = true;
		return () => {
			mounted.current = false;
		};
	}, []);
	return isMounted.current;
}

//#endregion
//#region node_modules/@restart/hooks/esm/useUpdatedRef.js
/**
* Returns a ref that is immediately updated with the new value
*
* @param value The Ref value
* @category refs
*/
function useUpdatedRef(value) {
	const valueRef = (0, import_react.useRef)(value);
	valueRef.current = value;
	return valueRef;
}

//#endregion
//#region node_modules/@restart/hooks/esm/useWillUnmount.js
/**
* Attach a callback that fires when a component unmounts
*
* @param fn Handler to run when the component unmounts
* @category effects
*/
function useWillUnmount(fn) {
	const onUnmount = useUpdatedRef(fn);
	(0, import_react.useEffect)(() => () => onUnmount.current(), []);
}

//#endregion
//#region node_modules/@restart/hooks/esm/useTimeout.js
var MAX_DELAY_MS = 2 ** 31 - 1;
function setChainedTimeout(handleRef, fn, timeoutAtMs) {
	const delayMs = timeoutAtMs - Date.now();
	handleRef.current = delayMs <= MAX_DELAY_MS ? setTimeout(fn, delayMs) : setTimeout(() => setChainedTimeout(handleRef, fn, timeoutAtMs), MAX_DELAY_MS);
}
/**
* Returns a controller object for setting a timeout that is properly cleaned up
* once the component unmounts. New timeouts cancel and replace existing ones.
*
*
*
* ```tsx
* const { set, clear } = useTimeout();
* const [hello, showHello] = useState(false);
* //Display hello after 5 seconds
* set(() => showHello(true), 5000);
* return (
*   <div className="App">
*     {hello ? <h3>Hello</h3> : null}
*   </div>
* );
* ```
*/
function useTimeout() {
	const isMounted = useMounted$1();
	const handleRef = (0, import_react.useRef)();
	useWillUnmount(() => clearTimeout(handleRef.current));
	return (0, import_react.useMemo)(() => {
		const clear = () => clearTimeout(handleRef.current);
		function set(fn, delayMs = 0) {
			if (!isMounted()) return;
			clear();
			if (delayMs <= MAX_DELAY_MS) handleRef.current = setTimeout(fn, delayMs);
			else setChainedTimeout(handleRef, fn, Date.now() + delayMs);
		}
		return {
			set,
			clear,
			handleRef
		};
	}, []);
}

//#endregion
//#region node_modules/react-bootstrap/esm/CarouselCaption.js
var import_classnames$58 = /* @__PURE__ */ __toESM(require_classnames());
var CarouselCaption = /* @__PURE__ */ import_react.forwardRef(({ className, bsPrefix, as: Component = "div",...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "carousel-caption");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		className: (0, import_classnames$58.default)(className, bsPrefix),
		...props
	});
});
CarouselCaption.displayName = "CarouselCaption";
var CarouselCaption_default = CarouselCaption;

//#endregion
//#region node_modules/react-bootstrap/esm/CarouselItem.js
var import_classnames$57 = /* @__PURE__ */ __toESM(require_classnames());
var CarouselItem = /* @__PURE__ */ import_react.forwardRef(({ as: Component = "div", bsPrefix, className,...props }, ref) => {
	const finalClassName = (0, import_classnames$57.default)(className, useBootstrapPrefix(bsPrefix, "carousel-item"));
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		...props,
		className: finalClassName
	});
});
CarouselItem.displayName = "CarouselItem";
var CarouselItem_default = CarouselItem;

//#endregion
//#region node_modules/react-bootstrap/esm/ElementChildren.js
/**
* Iterates through children that are typically specified as `props.children`,
* but only maps over children that are "valid elements".
*
* The mapFunction provided index will be normalised to the components mapped,
* so an invalid component would not increase the index.
*
*/
function map(children, func) {
	let index = 0;
	return import_react.Children.map(children, (child) => /* @__PURE__ */ import_react.isValidElement(child) ? func(child, index++) : child);
}
/**
* Iterates through children that are "valid elements".
*
* The provided forEachFunc(child, index) will be called for each
* leaf child with the index reflecting the position relative to "valid components".
*/
function forEach(children, func) {
	let index = 0;
	import_react.Children.forEach(children, (child) => {
		if (/* @__PURE__ */ import_react.isValidElement(child)) func(child, index++);
	});
}
/**
* Finds whether a component's `children` prop includes a React element of the
* specified type.
*/
function hasChildOfType(children, type) {
	return import_react.Children.toArray(children).some((child) => /* @__PURE__ */ import_react.isValidElement(child) && child.type === type);
}

//#endregion
//#region node_modules/react-bootstrap/esm/Carousel.js
var import_classnames$56 = /* @__PURE__ */ __toESM(require_classnames());
var SWIPE_THRESHOLD = 40;
function isVisible(element) {
	if (!element || !element.style || !element.parentNode || !element.parentNode.style) return false;
	const elementStyle = getComputedStyle(element);
	return elementStyle.display !== "none" && elementStyle.visibility !== "hidden" && getComputedStyle(element.parentNode).display !== "none";
}
var Carousel = /* @__PURE__ */ import_react.forwardRef(({ defaultActiveIndex = 0,...uncontrolledProps }, ref) => {
	const { as: Component = "div", bsPrefix, slide = true, fade = false, controls = true, indicators = true, indicatorLabels = [], activeIndex, onSelect, onSlide, onSlid, interval = 5e3, keyboard = true, onKeyDown, pause = "hover", onMouseOver, onMouseOut, wrap = true, touch = true, onTouchStart, onTouchMove, onTouchEnd, prevIcon = /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
		"aria-hidden": "true",
		className: "carousel-control-prev-icon"
	}), prevLabel = "Previous", nextIcon = /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
		"aria-hidden": "true",
		className: "carousel-control-next-icon"
	}), nextLabel = "Next", variant, className, children,...props } = useUncontrolled({
		defaultActiveIndex,
		...uncontrolledProps
	}, { activeIndex: "onSelect" });
	const prefix = useBootstrapPrefix(bsPrefix, "carousel");
	const isRTL = useIsRTL();
	const nextDirectionRef = (0, import_react.useRef)(null);
	const [direction, setDirection] = (0, import_react.useState)("next");
	const [paused, setPaused] = (0, import_react.useState)(false);
	const [isSliding, setIsSliding] = (0, import_react.useState)(false);
	const [renderedActiveIndex, setRenderedActiveIndex] = (0, import_react.useState)(activeIndex || 0);
	(0, import_react.useEffect)(() => {
		if (!isSliding && activeIndex !== renderedActiveIndex) {
			if (nextDirectionRef.current) setDirection(nextDirectionRef.current);
			else setDirection((activeIndex || 0) > renderedActiveIndex ? "next" : "prev");
			if (slide) setIsSliding(true);
			setRenderedActiveIndex(activeIndex || 0);
		}
	}, [
		activeIndex,
		isSliding,
		renderedActiveIndex,
		slide
	]);
	(0, import_react.useEffect)(() => {
		if (nextDirectionRef.current) nextDirectionRef.current = null;
	});
	let numChildren = 0;
	let activeChildInterval;
	forEach(children, (child, index) => {
		++numChildren;
		if (index === activeIndex) activeChildInterval = child.props.interval;
	});
	const activeChildIntervalRef = useCommittedRef_default(activeChildInterval);
	const prev = (0, import_react.useCallback)((event) => {
		if (isSliding) return;
		let nextActiveIndex = renderedActiveIndex - 1;
		if (nextActiveIndex < 0) {
			if (!wrap) return;
			nextActiveIndex = numChildren - 1;
		}
		nextDirectionRef.current = "prev";
		onSelect?.(nextActiveIndex, event);
	}, [
		isSliding,
		renderedActiveIndex,
		onSelect,
		wrap,
		numChildren
	]);
	const next = useEventCallback((event) => {
		if (isSliding) return;
		let nextActiveIndex = renderedActiveIndex + 1;
		if (nextActiveIndex >= numChildren) {
			if (!wrap) return;
			nextActiveIndex = 0;
		}
		nextDirectionRef.current = "next";
		onSelect?.(nextActiveIndex, event);
	});
	const elementRef = (0, import_react.useRef)();
	(0, import_react.useImperativeHandle)(ref, () => ({
		element: elementRef.current,
		prev,
		next
	}));
	const nextWhenVisible = useEventCallback(() => {
		if (!document.hidden && isVisible(elementRef.current)) if (isRTL) prev();
		else next();
	});
	const slideDirection = direction === "next" ? "start" : "end";
	useUpdateEffect_default(() => {
		if (slide) return;
		onSlide?.(renderedActiveIndex, slideDirection);
		onSlid?.(renderedActiveIndex, slideDirection);
	}, [renderedActiveIndex]);
	const orderClassName = `${prefix}-item-${direction}`;
	const directionalClassName = `${prefix}-item-${slideDirection}`;
	const handleEnter = (0, import_react.useCallback)((node) => {
		triggerBrowserReflow(node);
		onSlide?.(renderedActiveIndex, slideDirection);
	}, [
		onSlide,
		renderedActiveIndex,
		slideDirection
	]);
	const handleEntered = (0, import_react.useCallback)(() => {
		setIsSliding(false);
		onSlid?.(renderedActiveIndex, slideDirection);
	}, [
		onSlid,
		renderedActiveIndex,
		slideDirection
	]);
	const handleKeyDown = (0, import_react.useCallback)((event) => {
		if (keyboard && !/input|textarea/i.test(event.target.tagName)) switch (event.key) {
			case "ArrowLeft":
				event.preventDefault();
				if (isRTL) next(event);
				else prev(event);
				return;
			case "ArrowRight":
				event.preventDefault();
				if (isRTL) prev(event);
				else next(event);
				return;
			default:
		}
		onKeyDown?.(event);
	}, [
		keyboard,
		onKeyDown,
		prev,
		next,
		isRTL
	]);
	const handleMouseOver = (0, import_react.useCallback)((event) => {
		if (pause === "hover") setPaused(true);
		onMouseOver?.(event);
	}, [pause, onMouseOver]);
	const handleMouseOut = (0, import_react.useCallback)((event) => {
		setPaused(false);
		onMouseOut?.(event);
	}, [onMouseOut]);
	const touchStartXRef = (0, import_react.useRef)(0);
	const touchDeltaXRef = (0, import_react.useRef)(0);
	const touchUnpauseTimeout = useTimeout();
	const handleTouchStart = (0, import_react.useCallback)((event) => {
		touchStartXRef.current = event.touches[0].clientX;
		touchDeltaXRef.current = 0;
		if (pause === "hover") setPaused(true);
		onTouchStart?.(event);
	}, [pause, onTouchStart]);
	const handleTouchMove = (0, import_react.useCallback)((event) => {
		if (event.touches && event.touches.length > 1) touchDeltaXRef.current = 0;
		else touchDeltaXRef.current = event.touches[0].clientX - touchStartXRef.current;
		onTouchMove?.(event);
	}, [onTouchMove]);
	const handleTouchEnd = (0, import_react.useCallback)((event) => {
		if (touch) {
			const touchDeltaX = touchDeltaXRef.current;
			if (Math.abs(touchDeltaX) > SWIPE_THRESHOLD) if (touchDeltaX > 0) prev(event);
			else next(event);
		}
		if (pause === "hover") touchUnpauseTimeout.set(() => {
			setPaused(false);
		}, interval || void 0);
		onTouchEnd?.(event);
	}, [
		touch,
		pause,
		prev,
		next,
		touchUnpauseTimeout,
		interval,
		onTouchEnd
	]);
	const shouldPlay = interval != null && !paused && !isSliding;
	const intervalHandleRef = (0, import_react.useRef)();
	(0, import_react.useEffect)(() => {
		var _ref, _activeChildIntervalR;
		if (!shouldPlay) return;
		const nextFunc = isRTL ? prev : next;
		intervalHandleRef.current = window.setInterval(document.visibilityState ? nextWhenVisible : nextFunc, (_ref = (_activeChildIntervalR = activeChildIntervalRef.current) != null ? _activeChildIntervalR : interval) != null ? _ref : void 0);
		return () => {
			if (intervalHandleRef.current !== null) clearInterval(intervalHandleRef.current);
		};
	}, [
		shouldPlay,
		prev,
		next,
		activeChildIntervalRef,
		interval,
		nextWhenVisible,
		isRTL
	]);
	const indicatorOnClicks = (0, import_react.useMemo)(() => indicators && Array.from({ length: numChildren }, (_, index) => (event) => {
		onSelect?.(index, event);
	}), [
		indicators,
		numChildren,
		onSelect
	]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Component, {
		ref: elementRef,
		...props,
		onKeyDown: handleKeyDown,
		onMouseOver: handleMouseOver,
		onMouseOut: handleMouseOut,
		onTouchStart: handleTouchStart,
		onTouchMove: handleTouchMove,
		onTouchEnd: handleTouchEnd,
		className: (0, import_classnames$56.default)(className, prefix, slide && "slide", fade && `${prefix}-fade`, variant && `${prefix}-${variant}`),
		children: [
			indicators && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: `${prefix}-indicators`,
				children: map(children, (_, index) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("button", {
					type: "button",
					"data-bs-target": "",
					"aria-label": indicatorLabels != null && indicatorLabels.length ? indicatorLabels[index] : `Slide ${index + 1}`,
					className: index === renderedActiveIndex ? "active" : void 0,
					onClick: indicatorOnClicks ? indicatorOnClicks[index] : void 0,
					"aria-current": index === renderedActiveIndex
				}, index))
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: `${prefix}-inner`,
				children: map(children, (child, index) => {
					const isActive = index === renderedActiveIndex;
					return slide ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TransitionWrapper_default, {
						in: isActive,
						onEnter: isActive ? handleEnter : void 0,
						onEntered: isActive ? handleEntered : void 0,
						addEndListener: transitionEndListener,
						children: (status, innerProps) => /* @__PURE__ */ import_react.cloneElement(child, {
							...innerProps,
							className: (0, import_classnames$56.default)(child.props.className, isActive && status !== "entered" && orderClassName, (status === "entered" || status === "exiting") && "active", (status === "entering" || status === "exiting") && directionalClassName)
						})
					}) : /* @__PURE__ */ import_react.cloneElement(child, { className: (0, import_classnames$56.default)(child.props.className, isActive && "active") });
				})
			}),
			controls && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(wrap || activeIndex !== 0) && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Anchor_default$1, {
				className: `${prefix}-control-prev`,
				onClick: prev,
				children: [prevIcon, prevLabel && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
					className: "visually-hidden",
					children: prevLabel
				})]
			}), (wrap || activeIndex !== numChildren - 1) && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Anchor_default$1, {
				className: `${prefix}-control-next`,
				onClick: next,
				children: [nextIcon, nextLabel && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
					className: "visually-hidden",
					children: nextLabel
				})]
			})] })
		]
	});
});
Carousel.displayName = "Carousel";
var Carousel_default = Object.assign(Carousel, {
	Caption: CarouselCaption_default,
	Item: CarouselItem_default
});

//#endregion
//#region node_modules/react-bootstrap/esm/Col.js
var import_classnames$55 = /* @__PURE__ */ __toESM(require_classnames());
function useCol({ as, bsPrefix, className,...props }) {
	bsPrefix = useBootstrapPrefix(bsPrefix, "col");
	const breakpoints = useBootstrapBreakpoints();
	const minBreakpoint = useBootstrapMinBreakpoint();
	const spans = [];
	const classes = [];
	breakpoints.forEach((brkPoint) => {
		const propValue = props[brkPoint];
		delete props[brkPoint];
		let span;
		let offset$1;
		let order$1;
		if (typeof propValue === "object" && propValue != null) ({span, offset: offset$1, order: order$1} = propValue);
		else span = propValue;
		const infix = brkPoint !== minBreakpoint ? `-${brkPoint}` : "";
		if (span) spans.push(span === true ? `${bsPrefix}${infix}` : `${bsPrefix}${infix}-${span}`);
		if (order$1 != null) classes.push(`order${infix}-${order$1}`);
		if (offset$1 != null) classes.push(`offset${infix}-${offset$1}`);
	});
	return [{
		...props,
		className: (0, import_classnames$55.default)(className, ...spans, ...classes)
	}, {
		as,
		bsPrefix,
		spans
	}];
}
var Col = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const [{ className,...colProps }, { as: Component = "div", bsPrefix, spans }] = useCol(props);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		...colProps,
		ref,
		className: (0, import_classnames$55.default)(className, !spans.length && bsPrefix)
	});
});
Col.displayName = "Col";
var Col_default = Col;

//#endregion
//#region node_modules/@restart/ui/node_modules/uncontrollable/lib/esm/index.js
function useUncontrolledProp(propValue, defaultValue, handler) {
	const wasPropRef = (0, import_react.useRef)(propValue !== void 0);
	const [stateValue, setState] = (0, import_react.useState)(defaultValue);
	const isProp = propValue !== void 0;
	const wasProp = wasPropRef.current;
	wasPropRef.current = isProp;
	/**
	* If a prop switches from controlled to Uncontrolled
	* reset its value to the defaultValue
	*/
	if (!isProp && wasProp && stateValue !== defaultValue) setState(defaultValue);
	return [isProp ? propValue : stateValue, (0, import_react.useCallback)((...args) => {
		const [value, ...rest] = args;
		let returnValue = handler == null ? void 0 : handler(value, ...rest);
		setState(value);
		return returnValue;
	}, [handler])];
}

//#endregion
//#region node_modules/@restart/ui/esm/DropdownContext.js
var DropdownContext$1 = /* @__PURE__ */ import_react.createContext(null);
var DropdownContext_default$1 = DropdownContext$1;

//#endregion
//#region node_modules/dequal/dist/index.mjs
var has = Object.prototype.hasOwnProperty;
function find(iter, tar, key) {
	for (key of iter.keys()) if (dequal(key, tar)) return key;
}
function dequal(foo, bar) {
	var ctor, len, tmp;
	if (foo === bar) return true;
	if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
		if (ctor === Date) return foo.getTime() === bar.getTime();
		if (ctor === RegExp) return foo.toString() === bar.toString();
		if (ctor === Array) {
			if ((len = foo.length) === bar.length) while (len-- && dequal(foo[len], bar[len]));
			return len === -1;
		}
		if (ctor === Set) {
			if (foo.size !== bar.size) return false;
			for (len of foo) {
				tmp = len;
				if (tmp && typeof tmp === "object") {
					tmp = find(bar, tmp);
					if (!tmp) return false;
				}
				if (!bar.has(tmp)) return false;
			}
			return true;
		}
		if (ctor === Map) {
			if (foo.size !== bar.size) return false;
			for (len of foo) {
				tmp = len[0];
				if (tmp && typeof tmp === "object") {
					tmp = find(bar, tmp);
					if (!tmp) return false;
				}
				if (!dequal(len[1], bar.get(tmp))) return false;
			}
			return true;
		}
		if (ctor === ArrayBuffer) {
			foo = new Uint8Array(foo);
			bar = new Uint8Array(bar);
		} else if (ctor === DataView) {
			if ((len = foo.byteLength) === bar.byteLength) while (len-- && foo.getInt8(len) === bar.getInt8(len));
			return len === -1;
		}
		if (ArrayBuffer.isView(foo)) {
			if ((len = foo.byteLength) === bar.byteLength) while (len-- && foo[len] === bar[len]);
			return len === -1;
		}
		if (!ctor || typeof foo === "object") {
			len = 0;
			for (ctor in foo) {
				if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
				if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
			}
			return Object.keys(bar).length === len;
		}
	}
	return foo !== foo && bar !== bar;
}

//#endregion
//#region node_modules/@restart/ui/node_modules/@restart/hooks/esm/useSafeState.js
/**
* `useSafeState` takes the return value of a `useState` hook and wraps the
* setter to prevent updates onces the component has unmounted. Can used
* with `useMergeState` and `useStateAsync` as well
*
* @param state The return value of a useStateHook
*
* ```ts
* const [show, setShow] = useSafeState(useState(true));
* ```
*/
function useSafeState(state) {
	const isMounted = useMounted();
	return [state[0], (0, import_react.useCallback)((nextState) => {
		if (!isMounted()) return;
		return state[1](nextState);
	}, [isMounted, state[1]])];
}
var useSafeState_default = useSafeState;

//#endregion
//#region node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [
	top,
	bottom,
	right,
	left
];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
	return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
	return acc.concat([
		placement,
		placement + "-" + start,
		placement + "-" + end
	]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [
	beforeRead,
	read,
	afterRead,
	beforeMain,
	main,
	afterMain,
	beforeWrite,
	write,
	afterWrite
];

//#endregion
//#region node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
	return placement.split("-")[0];
}

//#endregion
//#region node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
	if (node == null) return window;
	if (node.toString() !== "[object Window]") {
		var ownerDocument$1 = node.ownerDocument;
		return ownerDocument$1 ? ownerDocument$1.defaultView || window : window;
	}
	return node;
}

//#endregion
//#region node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
	var OwnElement = getWindow(node).Element;
	return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
	var OwnElement = getWindow(node).HTMLElement;
	return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
	if (typeof ShadowRoot === "undefined") return false;
	var OwnElement = getWindow(node).ShadowRoot;
	return node instanceof OwnElement || node instanceof ShadowRoot;
}

//#endregion
//#region node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

//#endregion
//#region node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
	var uaData = navigator.userAgentData;
	if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) return uaData.brands.map(function(item) {
		return item.brand + "/" + item.version;
	}).join(" ");
	return navigator.userAgent;
}

//#endregion
//#region node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
	return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

//#endregion
//#region node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
	if (includeScale === void 0) includeScale = false;
	if (isFixedStrategy === void 0) isFixedStrategy = false;
	var clientRect = element.getBoundingClientRect();
	var scaleX = 1;
	var scaleY = 1;
	if (includeScale && isHTMLElement(element)) {
		scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
		scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
	}
	var visualViewport = (isElement(element) ? getWindow(element) : window).visualViewport;
	var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
	var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
	var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
	var width = clientRect.width / scaleX;
	var height = clientRect.height / scaleY;
	return {
		width,
		height,
		top: y,
		right: x + width,
		bottom: y + height,
		left: x,
		x,
		y
	};
}

//#endregion
//#region node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
	var clientRect = getBoundingClientRect(element);
	var width = element.offsetWidth;
	var height = element.offsetHeight;
	if (Math.abs(clientRect.width - width) <= 1) width = clientRect.width;
	if (Math.abs(clientRect.height - height) <= 1) height = clientRect.height;
	return {
		x: element.offsetLeft,
		y: element.offsetTop,
		width,
		height
	};
}

//#endregion
//#region node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains$1(parent, child) {
	var rootNode = child.getRootNode && child.getRootNode();
	if (parent.contains(child)) return true;
	else if (rootNode && isShadowRoot(rootNode)) {
		var next = child;
		do {
			if (next && parent.isSameNode(next)) return true;
			next = next.parentNode || next.host;
		} while (next);
	}
	return false;
}

//#endregion
//#region node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element) {
	return element ? (element.nodeName || "").toLowerCase() : null;
}

//#endregion
//#region node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle$1(element) {
	return getWindow(element).getComputedStyle(element);
}

//#endregion
//#region node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element) {
	return [
		"table",
		"td",
		"th"
	].indexOf(getNodeName(element)) >= 0;
}

//#endregion
//#region node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element) {
	return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}

//#endregion
//#region node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element) {
	if (getNodeName(element) === "html") return element;
	return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
}

//#endregion
//#region node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element) {
	if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") return null;
	return element.offsetParent;
}
function getContainingBlock(element) {
	var isFirefox = /firefox/i.test(getUAString());
	if (/Trident/i.test(getUAString()) && isHTMLElement(element)) {
		if (getComputedStyle$1(element).position === "fixed") return null;
	}
	var currentNode = getParentNode(element);
	if (isShadowRoot(currentNode)) currentNode = currentNode.host;
	while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
		var css = getComputedStyle$1(currentNode);
		if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") return currentNode;
		else currentNode = currentNode.parentNode;
	}
	return null;
}
function getOffsetParent(element) {
	var window$1 = getWindow(element);
	var offsetParent = getTrueOffsetParent(element);
	while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") offsetParent = getTrueOffsetParent(offsetParent);
	if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) return window$1;
	return offsetParent || getContainingBlock(element) || window$1;
}

//#endregion
//#region node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
	return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

//#endregion
//#region node_modules/@popperjs/core/lib/utils/within.js
function within(min$1, value, max$1) {
	return max(min$1, min(value, max$1));
}
function withinMaxClamp(min$1, value, max$1) {
	var v = within(min$1, value, max$1);
	return v > max$1 ? max$1 : v;
}

//#endregion
//#region node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
	return {
		top: 0,
		right: 0,
		bottom: 0,
		left: 0
	};
}

//#endregion
//#region node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
	return Object.assign({}, getFreshSideObject(), paddingObject);
}

//#endregion
//#region node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
	return keys.reduce(function(hashMap, key) {
		hashMap[key] = value;
		return hashMap;
	}, {});
}

//#endregion
//#region node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject$1(padding, state) {
	padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, { placement: state.placement })) : padding;
	return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
	var _state$modifiersData$;
	var state = _ref.state, name = _ref.name, options = _ref.options;
	var arrowElement = state.elements.arrow;
	var popperOffsets$1 = state.modifiersData.popperOffsets;
	var basePlacement = getBasePlacement(state.placement);
	var axis = getMainAxisFromPlacement(basePlacement);
	var len = [left, right].indexOf(basePlacement) >= 0 ? "height" : "width";
	if (!arrowElement || !popperOffsets$1) return;
	var paddingObject = toPaddingObject(options.padding, state);
	var arrowRect = getLayoutRect(arrowElement);
	var minProp = axis === "y" ? top : left;
	var maxProp = axis === "y" ? bottom : right;
	var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets$1[axis] - state.rects.popper[len];
	var startDiff = popperOffsets$1[axis] - state.rects.reference[axis];
	var arrowOffsetParent = getOffsetParent(arrowElement);
	var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
	var centerToReference = endDiff / 2 - startDiff / 2;
	var min$1 = paddingObject[minProp];
	var max$1 = clientSize - arrowRect[len] - paddingObject[maxProp];
	var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
	var offset$1 = within(min$1, center, max$1);
	var axisProp = axis;
	state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset$1, _state$modifiersData$.centerOffset = offset$1 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
	var state = _ref2.state;
	var _options$element = _ref2.options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
	if (arrowElement == null) return;
	if (typeof arrowElement === "string") {
		arrowElement = state.elements.popper.querySelector(arrowElement);
		if (!arrowElement) return;
	}
	if (!contains$1(state.elements.popper, arrowElement)) return;
	state.elements.arrow = arrowElement;
}
var arrow_default = {
	name: "arrow",
	enabled: true,
	phase: "main",
	fn: arrow,
	effect: effect$1,
	requires: ["popperOffsets"],
	requiresIfExists: ["preventOverflow"]
};

//#endregion
//#region node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
	return placement.split("-")[1];
}

//#endregion
//#region node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
	top: "auto",
	right: "auto",
	bottom: "auto",
	left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
	var x = _ref.x, y = _ref.y;
	var dpr = win.devicePixelRatio || 1;
	return {
		x: round(x * dpr) / dpr || 0,
		y: round(y * dpr) / dpr || 0
	};
}
function mapToStyles(_ref2) {
	var _Object$assign2;
	var popper$1 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
	var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
	var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
		x,
		y
	}) : {
		x,
		y
	};
	x = _ref3.x;
	y = _ref3.y;
	var hasX = offsets.hasOwnProperty("x");
	var hasY = offsets.hasOwnProperty("y");
	var sideX = left;
	var sideY = top;
	var win = window;
	if (adaptive) {
		var offsetParent = getOffsetParent(popper$1);
		var heightProp = "clientHeight";
		var widthProp = "clientWidth";
		if (offsetParent === getWindow(popper$1)) {
			offsetParent = getDocumentElement(popper$1);
			if (getComputedStyle$1(offsetParent).position !== "static" && position === "absolute") {
				heightProp = "scrollHeight";
				widthProp = "scrollWidth";
			}
		}
		offsetParent = offsetParent;
		if (placement === top || (placement === left || placement === right) && variation === end) {
			sideY = bottom;
			var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
			y -= offsetY - popperRect.height;
			y *= gpuAcceleration ? 1 : -1;
		}
		if (placement === left || (placement === top || placement === bottom) && variation === end) {
			sideX = right;
			var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
			x -= offsetX - popperRect.width;
			x *= gpuAcceleration ? 1 : -1;
		}
	}
	var commonStyles = Object.assign({ position }, adaptive && unsetSides);
	var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
		x,
		y
	}, getWindow(popper$1)) : {
		x,
		y
	};
	x = _ref4.x;
	y = _ref4.y;
	if (gpuAcceleration) {
		var _Object$assign;
		return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
	}
	return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
	var state = _ref5.state, options = _ref5.options;
	var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
	var commonStyles = {
		placement: getBasePlacement(state.placement),
		variation: getVariation(state.placement),
		popper: state.elements.popper,
		popperRect: state.rects.popper,
		gpuAcceleration,
		isFixed: state.options.strategy === "fixed"
	};
	if (state.modifiersData.popperOffsets != null) state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
		offsets: state.modifiersData.popperOffsets,
		position: state.options.strategy,
		adaptive,
		roundOffsets
	})));
	if (state.modifiersData.arrow != null) state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
		offsets: state.modifiersData.arrow,
		position: "absolute",
		adaptive: false,
		roundOffsets
	})));
	state.attributes.popper = Object.assign({}, state.attributes.popper, { "data-popper-placement": state.placement });
}
var computeStyles_default = {
	name: "computeStyles",
	enabled: true,
	phase: "beforeWrite",
	fn: computeStyles,
	data: {}
};

//#endregion
//#region node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = { passive: true };
function effect(_ref) {
	var state = _ref.state, instance = _ref.instance, options = _ref.options;
	var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
	var window$1 = getWindow(state.elements.popper);
	var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
	if (scroll) scrollParents.forEach(function(scrollParent) {
		scrollParent.addEventListener("scroll", instance.update, passive);
	});
	if (resize) window$1.addEventListener("resize", instance.update, passive);
	return function() {
		if (scroll) scrollParents.forEach(function(scrollParent) {
			scrollParent.removeEventListener("scroll", instance.update, passive);
		});
		if (resize) window$1.removeEventListener("resize", instance.update, passive);
	};
}
var eventListeners_default = {
	name: "eventListeners",
	enabled: true,
	phase: "write",
	fn: function fn() {},
	effect,
	data: {}
};

//#endregion
//#region node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash$1 = {
	left: "right",
	right: "left",
	bottom: "top",
	top: "bottom"
};
function getOppositePlacement(placement) {
	return placement.replace(/left|right|bottom|top/g, function(matched) {
		return hash$1[matched];
	});
}

//#endregion
//#region node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash = {
	start: "end",
	end: "start"
};
function getOppositeVariationPlacement(placement) {
	return placement.replace(/start|end/g, function(matched) {
		return hash[matched];
	});
}

//#endregion
//#region node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
	var win = getWindow(node);
	var scrollLeft = win.pageXOffset;
	var scrollTop = win.pageYOffset;
	return {
		scrollLeft,
		scrollTop
	};
}

//#endregion
//#region node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
	return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

//#endregion
//#region node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element, strategy) {
	var win = getWindow(element);
	var html = getDocumentElement(element);
	var visualViewport = win.visualViewport;
	var width = html.clientWidth;
	var height = html.clientHeight;
	var x = 0;
	var y = 0;
	if (visualViewport) {
		width = visualViewport.width;
		height = visualViewport.height;
		var layoutViewport = isLayoutViewport();
		if (layoutViewport || !layoutViewport && strategy === "fixed") {
			x = visualViewport.offsetLeft;
			y = visualViewport.offsetTop;
		}
	}
	return {
		width,
		height,
		x: x + getWindowScrollBarX(element),
		y
	};
}

//#endregion
//#region node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
	var _element$ownerDocumen;
	var html = getDocumentElement(element);
	var winScroll = getWindowScroll(element);
	var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
	var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
	var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
	var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
	var y = -winScroll.scrollTop;
	if (getComputedStyle$1(body || html).direction === "rtl") x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
	return {
		width,
		height,
		x,
		y
	};
}

//#endregion
//#region node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element) {
	var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
	return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

//#endregion
//#region node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
	if ([
		"html",
		"body",
		"#document"
	].indexOf(getNodeName(node)) >= 0) return node.ownerDocument.body;
	if (isHTMLElement(node) && isScrollParent(node)) return node;
	return getScrollParent(getParentNode(node));
}

//#endregion
//#region node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element, list) {
	var _element$ownerDocumen;
	if (list === void 0) list = [];
	var scrollParent = getScrollParent(element);
	var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
	var win = getWindow(scrollParent);
	var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
	var updatedList = list.concat(target);
	return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}

//#endregion
//#region node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
	return Object.assign({}, rect, {
		left: rect.x,
		top: rect.y,
		right: rect.x + rect.width,
		bottom: rect.y + rect.height
	});
}

//#endregion
//#region node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element, strategy) {
	var rect = getBoundingClientRect(element, false, strategy === "fixed");
	rect.top = rect.top + element.clientTop;
	rect.left = rect.left + element.clientLeft;
	rect.bottom = rect.top + element.clientHeight;
	rect.right = rect.left + element.clientWidth;
	rect.width = element.clientWidth;
	rect.height = element.clientHeight;
	rect.x = rect.left;
	rect.y = rect.top;
	return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
	return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
	var clippingParents$1 = listScrollParents(getParentNode(element));
	var clipperElement = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0 && isHTMLElement(element) ? getOffsetParent(element) : element;
	if (!isElement(clipperElement)) return [];
	return clippingParents$1.filter(function(clippingParent) {
		return isElement(clippingParent) && contains$1(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
	});
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
	var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
	var clippingParents$1 = [].concat(mainClippingParents, [rootBoundary]);
	var firstClippingParent = clippingParents$1[0];
	var clippingRect = clippingParents$1.reduce(function(accRect, clippingParent) {
		var rect = getClientRectFromMixedType(element, clippingParent, strategy);
		accRect.top = max(rect.top, accRect.top);
		accRect.right = min(rect.right, accRect.right);
		accRect.bottom = min(rect.bottom, accRect.bottom);
		accRect.left = max(rect.left, accRect.left);
		return accRect;
	}, getClientRectFromMixedType(element, firstClippingParent, strategy));
	clippingRect.width = clippingRect.right - clippingRect.left;
	clippingRect.height = clippingRect.bottom - clippingRect.top;
	clippingRect.x = clippingRect.left;
	clippingRect.y = clippingRect.top;
	return clippingRect;
}

//#endregion
//#region node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
	var reference$1 = _ref.reference, element = _ref.element, placement = _ref.placement;
	var basePlacement = placement ? getBasePlacement(placement) : null;
	var variation = placement ? getVariation(placement) : null;
	var commonX = reference$1.x + reference$1.width / 2 - element.width / 2;
	var commonY = reference$1.y + reference$1.height / 2 - element.height / 2;
	var offsets;
	switch (basePlacement) {
		case top:
			offsets = {
				x: commonX,
				y: reference$1.y - element.height
			};
			break;
		case bottom:
			offsets = {
				x: commonX,
				y: reference$1.y + reference$1.height
			};
			break;
		case right:
			offsets = {
				x: reference$1.x + reference$1.width,
				y: commonY
			};
			break;
		case left:
			offsets = {
				x: reference$1.x - element.width,
				y: commonY
			};
			break;
		default: offsets = {
			x: reference$1.x,
			y: reference$1.y
		};
	}
	var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
	if (mainAxis != null) {
		var len = mainAxis === "y" ? "height" : "width";
		switch (variation) {
			case start:
				offsets[mainAxis] = offsets[mainAxis] - (reference$1[len] / 2 - element[len] / 2);
				break;
			case end:
				offsets[mainAxis] = offsets[mainAxis] + (reference$1[len] / 2 - element[len] / 2);
				break;
			default:
		}
	}
	return offsets;
}

//#endregion
//#region node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
	if (options === void 0) options = {};
	var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
	var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
	var altContext = elementContext === popper ? reference : popper;
	var popperRect = state.rects.popper;
	var element = state.elements[altBoundary ? altContext : elementContext];
	var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
	var referenceClientRect = getBoundingClientRect(state.elements.reference);
	var popperOffsets$1 = computeOffsets({
		reference: referenceClientRect,
		element: popperRect,
		strategy: "absolute",
		placement
	});
	var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets$1));
	var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
	var overflowOffsets = {
		top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
		bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
		left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
		right: elementClientRect.right - clippingClientRect.right + paddingObject.right
	};
	var offsetData = state.modifiersData.offset;
	if (elementContext === popper && offsetData) {
		var offset$1 = offsetData[placement];
		Object.keys(overflowOffsets).forEach(function(key) {
			var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
			var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
			overflowOffsets[key] += offset$1[axis] * multiply;
		});
	}
	return overflowOffsets;
}

//#endregion
//#region node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
	if (options === void 0) options = {};
	var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
	var variation = getVariation(placement);
	var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement$1) {
		return getVariation(placement$1) === variation;
	}) : basePlacements;
	var allowedPlacements = placements$1.filter(function(placement$1) {
		return allowedAutoPlacements.indexOf(placement$1) >= 0;
	});
	if (allowedPlacements.length === 0) allowedPlacements = placements$1;
	var overflows = allowedPlacements.reduce(function(acc, placement$1) {
		acc[placement$1] = detectOverflow(state, {
			placement: placement$1,
			boundary,
			rootBoundary,
			padding
		})[getBasePlacement(placement$1)];
		return acc;
	}, {});
	return Object.keys(overflows).sort(function(a, b) {
		return overflows[a] - overflows[b];
	});
}

//#endregion
//#region node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
	if (getBasePlacement(placement) === auto) return [];
	var oppositePlacement = getOppositePlacement(placement);
	return [
		getOppositeVariationPlacement(placement),
		oppositePlacement,
		getOppositeVariationPlacement(oppositePlacement)
	];
}
function flip(_ref) {
	var state = _ref.state, options = _ref.options, name = _ref.name;
	if (state.modifiersData[name]._skip) return;
	var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
	var preferredPlacement = state.options.placement;
	var isBasePlacement = getBasePlacement(preferredPlacement) === preferredPlacement;
	var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
	var placements$1 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement$1) {
		return acc.concat(getBasePlacement(placement$1) === auto ? computeAutoPlacement(state, {
			placement: placement$1,
			boundary,
			rootBoundary,
			padding,
			flipVariations,
			allowedAutoPlacements
		}) : placement$1);
	}, []);
	var referenceRect = state.rects.reference;
	var popperRect = state.rects.popper;
	var checksMap = /* @__PURE__ */ new Map();
	var makeFallbackChecks = true;
	var firstFittingPlacement = placements$1[0];
	for (var i = 0; i < placements$1.length; i++) {
		var placement = placements$1[i];
		var _basePlacement = getBasePlacement(placement);
		var isStartVariation = getVariation(placement) === start;
		var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
		var len = isVertical ? "width" : "height";
		var overflow = detectOverflow(state, {
			placement,
			boundary,
			rootBoundary,
			altBoundary,
			padding
		});
		var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
		if (referenceRect[len] > popperRect[len]) mainVariationSide = getOppositePlacement(mainVariationSide);
		var altVariationSide = getOppositePlacement(mainVariationSide);
		var checks = [];
		if (checkMainAxis) checks.push(overflow[_basePlacement] <= 0);
		if (checkAltAxis) checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
		if (checks.every(function(check) {
			return check;
		})) {
			firstFittingPlacement = placement;
			makeFallbackChecks = false;
			break;
		}
		checksMap.set(placement, checks);
	}
	if (makeFallbackChecks) {
		var numberOfChecks = flipVariations ? 3 : 1;
		var _loop = function _loop$1(_i$1) {
			var fittingPlacement = placements$1.find(function(placement$1) {
				var checks$1 = checksMap.get(placement$1);
				if (checks$1) return checks$1.slice(0, _i$1).every(function(check) {
					return check;
				});
			});
			if (fittingPlacement) {
				firstFittingPlacement = fittingPlacement;
				return "break";
			}
		};
		for (var _i = numberOfChecks; _i > 0; _i--) if (_loop(_i) === "break") break;
	}
	if (state.placement !== firstFittingPlacement) {
		state.modifiersData[name]._skip = true;
		state.placement = firstFittingPlacement;
		state.reset = true;
	}
}
var flip_default = {
	name: "flip",
	enabled: true,
	phase: "main",
	fn: flip,
	requiresIfExists: ["offset"],
	data: { _skip: false }
};

//#endregion
//#region node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
	if (preventedOffsets === void 0) preventedOffsets = {
		x: 0,
		y: 0
	};
	return {
		top: overflow.top - rect.height - preventedOffsets.y,
		right: overflow.right - rect.width + preventedOffsets.x,
		bottom: overflow.bottom - rect.height + preventedOffsets.y,
		left: overflow.left - rect.width - preventedOffsets.x
	};
}
function isAnySideFullyClipped(overflow) {
	return [
		top,
		right,
		bottom,
		left
	].some(function(side) {
		return overflow[side] >= 0;
	});
}
function hide(_ref) {
	var state = _ref.state, name = _ref.name;
	var referenceRect = state.rects.reference;
	var popperRect = state.rects.popper;
	var preventedOffsets = state.modifiersData.preventOverflow;
	var referenceOverflow = detectOverflow(state, { elementContext: "reference" });
	var popperAltOverflow = detectOverflow(state, { altBoundary: true });
	var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
	var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
	var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
	var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
	state.modifiersData[name] = {
		referenceClippingOffsets,
		popperEscapeOffsets,
		isReferenceHidden,
		hasPopperEscaped
	};
	state.attributes.popper = Object.assign({}, state.attributes.popper, {
		"data-popper-reference-hidden": isReferenceHidden,
		"data-popper-escaped": hasPopperEscaped
	});
}
var hide_default = {
	name: "hide",
	enabled: true,
	phase: "main",
	requiresIfExists: ["preventOverflow"],
	fn: hide
};

//#endregion
//#region node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset$1) {
	var basePlacement = getBasePlacement(placement);
	var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
	var _ref = typeof offset$1 === "function" ? offset$1(Object.assign({}, rects, { placement })) : offset$1, skidding = _ref[0], distance = _ref[1];
	skidding = skidding || 0;
	distance = (distance || 0) * invertDistance;
	return [left, right].indexOf(basePlacement) >= 0 ? {
		x: distance,
		y: skidding
	} : {
		x: skidding,
		y: distance
	};
}
function offset(_ref2) {
	var state = _ref2.state, options = _ref2.options, name = _ref2.name;
	var _options$offset = options.offset, offset$1 = _options$offset === void 0 ? [0, 0] : _options$offset;
	var data = placements.reduce(function(acc, placement) {
		acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset$1);
		return acc;
	}, {});
	var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
	if (state.modifiersData.popperOffsets != null) {
		state.modifiersData.popperOffsets.x += x;
		state.modifiersData.popperOffsets.y += y;
	}
	state.modifiersData[name] = data;
}
var offset_default = {
	name: "offset",
	enabled: true,
	phase: "main",
	requires: ["popperOffsets"],
	fn: offset
};

//#endregion
//#region node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
	var state = _ref.state, name = _ref.name;
	state.modifiersData[name] = computeOffsets({
		reference: state.rects.reference,
		element: state.rects.popper,
		strategy: "absolute",
		placement: state.placement
	});
}
var popperOffsets_default = {
	name: "popperOffsets",
	enabled: true,
	phase: "read",
	fn: popperOffsets,
	data: {}
};

//#endregion
//#region node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
	return axis === "x" ? "y" : "x";
}

//#endregion
//#region node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
	var state = _ref.state, options = _ref.options, name = _ref.name;
	var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
	var overflow = detectOverflow(state, {
		boundary,
		rootBoundary,
		padding,
		altBoundary
	});
	var basePlacement = getBasePlacement(state.placement);
	var variation = getVariation(state.placement);
	var isBasePlacement = !variation;
	var mainAxis = getMainAxisFromPlacement(basePlacement);
	var altAxis = getAltAxis(mainAxis);
	var popperOffsets$1 = state.modifiersData.popperOffsets;
	var referenceRect = state.rects.reference;
	var popperRect = state.rects.popper;
	var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, { placement: state.placement })) : tetherOffset;
	var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
		mainAxis: tetherOffsetValue,
		altAxis: tetherOffsetValue
	} : Object.assign({
		mainAxis: 0,
		altAxis: 0
	}, tetherOffsetValue);
	var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
	var data = {
		x: 0,
		y: 0
	};
	if (!popperOffsets$1) return;
	if (checkMainAxis) {
		var _offsetModifierState$;
		var mainSide = mainAxis === "y" ? top : left;
		var altSide = mainAxis === "y" ? bottom : right;
		var len = mainAxis === "y" ? "height" : "width";
		var offset$1 = popperOffsets$1[mainAxis];
		var min$1 = offset$1 + overflow[mainSide];
		var max$1 = offset$1 - overflow[altSide];
		var additive = tether ? -popperRect[len] / 2 : 0;
		var minLen = variation === start ? referenceRect[len] : popperRect[len];
		var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
		var arrowElement = state.elements.arrow;
		var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
			width: 0,
			height: 0
		};
		var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
		var arrowPaddingMin = arrowPaddingObject[mainSide];
		var arrowPaddingMax = arrowPaddingObject[altSide];
		var arrowLen = within(0, referenceRect[len], arrowRect[len]);
		var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
		var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
		var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
		var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
		var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
		var tetherMin = offset$1 + minOffset - offsetModifierValue - clientOffset;
		var tetherMax = offset$1 + maxOffset - offsetModifierValue;
		var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset$1, tether ? max(max$1, tetherMax) : max$1);
		popperOffsets$1[mainAxis] = preventedOffset;
		data[mainAxis] = preventedOffset - offset$1;
	}
	if (checkAltAxis) {
		var _offsetModifierState$2;
		var _mainSide = mainAxis === "x" ? top : left;
		var _altSide = mainAxis === "x" ? bottom : right;
		var _offset = popperOffsets$1[altAxis];
		var _len = altAxis === "y" ? "height" : "width";
		var _min = _offset + overflow[_mainSide];
		var _max = _offset - overflow[_altSide];
		var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
		var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
		var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
		var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
		var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
		popperOffsets$1[altAxis] = _preventedOffset;
		data[altAxis] = _preventedOffset - _offset;
	}
	state.modifiersData[name] = data;
}
var preventOverflow_default = {
	name: "preventOverflow",
	enabled: true,
	phase: "main",
	fn: preventOverflow,
	requiresIfExists: ["offset"]
};

//#endregion
//#region node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
	return {
		scrollLeft: element.scrollLeft,
		scrollTop: element.scrollTop
	};
}

//#endregion
//#region node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
	if (node === getWindow(node) || !isHTMLElement(node)) return getWindowScroll(node);
	else return getHTMLElementScroll(node);
}

//#endregion
//#region node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element) {
	var rect = element.getBoundingClientRect();
	var scaleX = round(rect.width) / element.offsetWidth || 1;
	var scaleY = round(rect.height) / element.offsetHeight || 1;
	return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
	if (isFixed === void 0) isFixed = false;
	var isOffsetParentAnElement = isHTMLElement(offsetParent);
	var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
	var documentElement = getDocumentElement(offsetParent);
	var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
	var scroll = {
		scrollLeft: 0,
		scrollTop: 0
	};
	var offsets = {
		x: 0,
		y: 0
	};
	if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
		if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) scroll = getNodeScroll(offsetParent);
		if (isHTMLElement(offsetParent)) {
			offsets = getBoundingClientRect(offsetParent, true);
			offsets.x += offsetParent.clientLeft;
			offsets.y += offsetParent.clientTop;
		} else if (documentElement) offsets.x = getWindowScrollBarX(documentElement);
	}
	return {
		x: rect.left + scroll.scrollLeft - offsets.x,
		y: rect.top + scroll.scrollTop - offsets.y,
		width: rect.width,
		height: rect.height
	};
}

//#endregion
//#region node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
	var map$1 = /* @__PURE__ */ new Map();
	var visited = /* @__PURE__ */ new Set();
	var result = [];
	modifiers.forEach(function(modifier) {
		map$1.set(modifier.name, modifier);
	});
	function sort(modifier) {
		visited.add(modifier.name);
		[].concat(modifier.requires || [], modifier.requiresIfExists || []).forEach(function(dep) {
			if (!visited.has(dep)) {
				var depModifier = map$1.get(dep);
				if (depModifier) sort(depModifier);
			}
		});
		result.push(modifier);
	}
	modifiers.forEach(function(modifier) {
		if (!visited.has(modifier.name)) sort(modifier);
	});
	return result;
}
function orderModifiers(modifiers) {
	var orderedModifiers = order(modifiers);
	return modifierPhases.reduce(function(acc, phase) {
		return acc.concat(orderedModifiers.filter(function(modifier) {
			return modifier.phase === phase;
		}));
	}, []);
}

//#endregion
//#region node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn) {
	var pending;
	return function() {
		if (!pending) pending = new Promise(function(resolve) {
			Promise.resolve().then(function() {
				pending = void 0;
				resolve(fn());
			});
		});
		return pending;
	};
}

//#endregion
//#region node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
	var merged = modifiers.reduce(function(merged$1, current) {
		var existing = merged$1[current.name];
		merged$1[current.name] = existing ? Object.assign({}, existing, current, {
			options: Object.assign({}, existing.options, current.options),
			data: Object.assign({}, existing.data, current.data)
		}) : current;
		return merged$1;
	}, {});
	return Object.keys(merged).map(function(key) {
		return merged[key];
	});
}

//#endregion
//#region node_modules/@popperjs/core/lib/createPopper.js
var DEFAULT_OPTIONS = {
	placement: "bottom",
	modifiers: [],
	strategy: "absolute"
};
function areValidElements() {
	for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
	return !args.some(function(element) {
		return !(element && typeof element.getBoundingClientRect === "function");
	});
}
function popperGenerator(generatorOptions) {
	if (generatorOptions === void 0) generatorOptions = {};
	var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
	return function createPopper$1(reference$1, popper$1, options) {
		if (options === void 0) options = defaultOptions;
		var state = {
			placement: "bottom",
			orderedModifiers: [],
			options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
			modifiersData: {},
			elements: {
				reference: reference$1,
				popper: popper$1
			},
			attributes: {},
			styles: {}
		};
		var effectCleanupFns = [];
		var isDestroyed = false;
		var instance = {
			state,
			setOptions: function setOptions(setOptionsAction) {
				var options$1 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
				cleanupModifierEffects();
				state.options = Object.assign({}, defaultOptions, state.options, options$1);
				state.scrollParents = {
					reference: isElement(reference$1) ? listScrollParents(reference$1) : reference$1.contextElement ? listScrollParents(reference$1.contextElement) : [],
					popper: listScrollParents(popper$1)
				};
				state.orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))).filter(function(m) {
					return m.enabled;
				});
				runModifierEffects();
				return instance.update();
			},
			forceUpdate: function forceUpdate() {
				if (isDestroyed) return;
				var _state$elements = state.elements, reference$2 = _state$elements.reference, popper$2 = _state$elements.popper;
				if (!areValidElements(reference$2, popper$2)) return;
				state.rects = {
					reference: getCompositeRect(reference$2, getOffsetParent(popper$2), state.options.strategy === "fixed"),
					popper: getLayoutRect(popper$2)
				};
				state.reset = false;
				state.placement = state.options.placement;
				state.orderedModifiers.forEach(function(modifier) {
					return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
				});
				for (var index = 0; index < state.orderedModifiers.length; index++) {
					if (state.reset === true) {
						state.reset = false;
						index = -1;
						continue;
					}
					var _state$orderedModifie = state.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
					if (typeof fn === "function") state = fn({
						state,
						options: _options,
						name,
						instance
					}) || state;
				}
			},
			update: debounce(function() {
				return new Promise(function(resolve) {
					instance.forceUpdate();
					resolve(state);
				});
			}),
			destroy: function destroy() {
				cleanupModifierEffects();
				isDestroyed = true;
			}
		};
		if (!areValidElements(reference$1, popper$1)) return instance;
		instance.setOptions(options).then(function(state$1) {
			if (!isDestroyed && options.onFirstUpdate) options.onFirstUpdate(state$1);
		});
		function runModifierEffects() {
			state.orderedModifiers.forEach(function(_ref) {
				var name = _ref.name, _ref$options = _ref.options, options$1 = _ref$options === void 0 ? {} : _ref$options, effect$2 = _ref.effect;
				if (typeof effect$2 === "function") {
					var cleanupFn = effect$2({
						state,
						name,
						instance,
						options: options$1
					});
					effectCleanupFns.push(cleanupFn || function noopFn() {});
				}
			});
		}
		function cleanupModifierEffects() {
			effectCleanupFns.forEach(function(fn) {
				return fn();
			});
			effectCleanupFns = [];
		}
		return instance;
	};
}

//#endregion
//#region node_modules/@restart/ui/esm/popper.js
const createPopper = popperGenerator({ defaultModifiers: [
	hide_default,
	popperOffsets_default,
	computeStyles_default,
	eventListeners_default,
	offset_default,
	flip_default,
	preventOverflow_default,
	arrow_default
] });

//#endregion
//#region node_modules/@restart/ui/esm/usePopper.js
var _excluded$3 = [
	"enabled",
	"placement",
	"strategy",
	"modifiers"
];
function _objectWithoutPropertiesLoose$3(r, e) {
	if (null == r) return {};
	var t = {};
	for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
		if (e.indexOf(n) >= 0) continue;
		t[n] = r[n];
	}
	return t;
}
var disabledApplyStylesModifier = {
	name: "applyStyles",
	enabled: false,
	phase: "afterWrite",
	fn: () => void 0
};
var ariaDescribedByModifier = {
	name: "ariaDescribedBy",
	enabled: true,
	phase: "afterWrite",
	effect: ({ state }) => () => {
		const { reference: reference$1, popper: popper$1 } = state.elements;
		if ("removeAttribute" in reference$1) {
			const ids = (reference$1.getAttribute("aria-describedby") || "").split(",").filter((id) => id.trim() !== popper$1.id);
			if (!ids.length) reference$1.removeAttribute("aria-describedby");
			else reference$1.setAttribute("aria-describedby", ids.join(","));
		}
	},
	fn: ({ state }) => {
		var _popper$getAttribute;
		const { popper: popper$1, reference: reference$1 } = state.elements;
		const role = (_popper$getAttribute = popper$1.getAttribute("role")) == null ? void 0 : _popper$getAttribute.toLowerCase();
		if (popper$1.id && role === "tooltip" && "setAttribute" in reference$1) {
			const ids = reference$1.getAttribute("aria-describedby");
			if (ids && ids.split(",").indexOf(popper$1.id) !== -1) return;
			reference$1.setAttribute("aria-describedby", ids ? `${ids},${popper$1.id}` : popper$1.id);
		}
	}
};
var EMPTY_MODIFIERS = [];
/**
* Position an element relative some reference element using Popper.js
*
* @param referenceElement
* @param popperElement
* @param {object}      options
* @param {object=}     options.modifiers Popper.js modifiers
* @param {boolean=}    options.enabled toggle the popper functionality on/off
* @param {string=}     options.placement The popper element placement relative to the reference element
* @param {string=}     options.strategy the positioning strategy
* @param {function=}   options.onCreate called when the popper is created
* @param {function=}   options.onUpdate called when the popper is updated
*
* @returns {UsePopperState} The popper state
*/
function usePopper(referenceElement, popperElement, _ref = {}) {
	let { enabled = true, placement = "bottom", strategy = "absolute", modifiers = EMPTY_MODIFIERS } = _ref, config = _objectWithoutPropertiesLoose$3(_ref, _excluded$3);
	const prevModifiers = (0, import_react.useRef)(modifiers);
	const popperInstanceRef = (0, import_react.useRef)();
	const update = (0, import_react.useCallback)(() => {
		var _popperInstanceRef$cu;
		(_popperInstanceRef$cu = popperInstanceRef.current) == null || _popperInstanceRef$cu.update();
	}, []);
	const forceUpdate = (0, import_react.useCallback)(() => {
		var _popperInstanceRef$cu2;
		(_popperInstanceRef$cu2 = popperInstanceRef.current) == null || _popperInstanceRef$cu2.forceUpdate();
	}, []);
	const [popperState, setState] = useSafeState_default((0, import_react.useState)({
		placement,
		update,
		forceUpdate,
		attributes: {},
		styles: {
			popper: {},
			arrow: {}
		}
	}));
	const updateModifier = (0, import_react.useMemo)(() => ({
		name: "updateStateModifier",
		enabled: true,
		phase: "write",
		requires: ["computeStyles"],
		fn: ({ state }) => {
			const styles = {};
			const attributes = {};
			Object.keys(state.elements).forEach((element) => {
				styles[element] = state.styles[element];
				attributes[element] = state.attributes[element];
			});
			setState({
				state,
				styles,
				attributes,
				update,
				forceUpdate,
				placement: state.placement
			});
		}
	}), [
		update,
		forceUpdate,
		setState
	]);
	const nextModifiers = (0, import_react.useMemo)(() => {
		if (!dequal(prevModifiers.current, modifiers)) prevModifiers.current = modifiers;
		return prevModifiers.current;
	}, [modifiers]);
	(0, import_react.useEffect)(() => {
		if (!popperInstanceRef.current || !enabled) return;
		popperInstanceRef.current.setOptions({
			placement,
			strategy,
			modifiers: [
				...nextModifiers,
				updateModifier,
				disabledApplyStylesModifier
			]
		});
	}, [
		strategy,
		placement,
		updateModifier,
		enabled,
		nextModifiers
	]);
	(0, import_react.useEffect)(() => {
		if (!enabled || referenceElement == null || popperElement == null) return;
		popperInstanceRef.current = createPopper(referenceElement, popperElement, Object.assign({}, config, {
			placement,
			strategy,
			modifiers: [
				...nextModifiers,
				ariaDescribedByModifier,
				updateModifier
			]
		}));
		return () => {
			if (popperInstanceRef.current != null) {
				popperInstanceRef.current.destroy();
				popperInstanceRef.current = void 0;
				setState((s) => Object.assign({}, s, {
					attributes: {},
					styles: { popper: {} }
				}));
			}
		};
	}, [
		enabled,
		referenceElement,
		popperElement
	]);
	return popperState;
}
var usePopper_default = usePopper;

//#endregion
//#region node_modules/warning/warning.js
var require_warning = /* @__PURE__ */ __commonJS({ "node_modules/warning/warning.js": ((exports, module) => {
	/**
	* Similar to invariant but only logs a warning if the condition is not met.
	* This can be used to log issues in development environments in critical
	* paths. Removing the logging code for production environments will keep the
	* same logic and follow the same code paths.
	*/
	var __DEV__ = true;
	var warning$7 = function() {};
	if (__DEV__) {
		var printWarning = function printWarning$1(format, args) {
			var len = arguments.length;
			args = new Array(len > 1 ? len - 1 : 0);
			for (var key = 1; key < len; key++) args[key - 1] = arguments[key];
			var argIndex = 0;
			var message = "Warning: " + format.replace(/%s/g, function() {
				return args[argIndex++];
			});
			if (typeof console !== "undefined") console.error(message);
			try {
				throw new Error(message);
			} catch (x) {}
		};
		warning$7 = function(condition, format, args) {
			var len = arguments.length;
			args = new Array(len > 2 ? len - 2 : 0);
			for (var key = 2; key < len; key++) args[key - 2] = arguments[key];
			if (format === void 0) throw new Error("`warning(condition, format, ...args)` requires a warning message argument");
			if (!condition) printWarning.apply(null, [format].concat(args));
		};
	}
	module.exports = warning$7;
}) });

//#endregion
//#region node_modules/@restart/ui/esm/useClickOutside.js
var import_warning$6 = /* @__PURE__ */ __toESM(require_warning());
var noop$4 = () => {};
function isLeftClickEvent(event) {
	return event.button === 0;
}
function isModifiedEvent(event) {
	return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
const getRefTarget = (ref) => ref && ("current" in ref ? ref.current : ref);
var InitialTriggerEvents = {
	click: "mousedown",
	mouseup: "mousedown",
	pointerup: "pointerdown"
};
/**
* The `useClickOutside` hook registers your callback on the document that fires
* when a pointer event is registered outside of the provided ref or element.
*
* @param {Ref<HTMLElement>| HTMLElement} ref  The element boundary
* @param {function} onClickOutside
* @param {object=}  options
* @param {boolean=} options.disabled
* @param {string=}  options.clickTrigger The DOM event name (click, mousedown, etc) to attach listeners on
*/
function useClickOutside(ref, onClickOutside = noop$4, { disabled, clickTrigger = "click" } = {}) {
	const preventMouseClickOutsideRef = (0, import_react.useRef)(false);
	const waitingForTrigger = (0, import_react.useRef)(false);
	const handleMouseCapture = (0, import_react.useCallback)((e) => {
		const currentTarget = getRefTarget(ref);
		(0, import_warning$6.default)(!!currentTarget, "ClickOutside captured a close event but does not have a ref to compare it to. useClickOutside(), should be passed a ref that resolves to a DOM node");
		preventMouseClickOutsideRef.current = !currentTarget || isModifiedEvent(e) || !isLeftClickEvent(e) || !!contains(currentTarget, e.target) || waitingForTrigger.current;
		waitingForTrigger.current = false;
	}, [ref]);
	const handleInitialMouse = useEventCallback$1((e) => {
		const currentTarget = getRefTarget(ref);
		if (currentTarget && contains(currentTarget, e.target)) waitingForTrigger.current = true;
		else waitingForTrigger.current = false;
	});
	const handleMouse = useEventCallback$1((e) => {
		if (!preventMouseClickOutsideRef.current) onClickOutside(e);
	});
	(0, import_react.useEffect)(() => {
		var _ownerWindow$event, _ownerWindow$parent;
		if (disabled || ref == null) return void 0;
		const doc = ownerDocument(getRefTarget(ref));
		const ownerWindow = doc.defaultView || window;
		let currentEvent = (_ownerWindow$event = ownerWindow.event) != null ? _ownerWindow$event : (_ownerWindow$parent = ownerWindow.parent) == null ? void 0 : _ownerWindow$parent.event;
		let removeInitialTriggerListener = null;
		if (InitialTriggerEvents[clickTrigger]) removeInitialTriggerListener = listen_default(doc, InitialTriggerEvents[clickTrigger], handleInitialMouse, true);
		const removeMouseCaptureListener = listen_default(doc, clickTrigger, handleMouseCapture, true);
		const removeMouseListener = listen_default(doc, clickTrigger, (e) => {
			if (e === currentEvent) {
				currentEvent = void 0;
				return;
			}
			handleMouse(e);
		});
		let mobileSafariHackListeners = [];
		if ("ontouchstart" in doc.documentElement) mobileSafariHackListeners = [].slice.call(doc.body.children).map((el) => listen_default(el, "mousemove", noop$4));
		return () => {
			removeInitialTriggerListener?.();
			removeMouseCaptureListener();
			removeMouseListener();
			mobileSafariHackListeners.forEach((remove) => remove());
		};
	}, [
		ref,
		disabled,
		clickTrigger,
		handleMouseCapture,
		handleInitialMouse,
		handleMouse
	]);
}
var useClickOutside_default = useClickOutside;

//#endregion
//#region node_modules/@restart/ui/esm/mergeOptionsWithPopperConfig.js
function toModifierMap(modifiers) {
	const result = {};
	if (!Array.isArray(modifiers)) return modifiers || result;
	modifiers?.forEach((m) => {
		result[m.name] = m;
	});
	return result;
}
function toModifierArray(map$1 = {}) {
	if (Array.isArray(map$1)) return map$1;
	return Object.keys(map$1).map((k) => {
		map$1[k].name = k;
		return map$1[k];
	});
}
function mergeOptionsWithPopperConfig({ enabled, enableEvents, placement, flip: flip$1, offset: offset$1, fixed, containerPadding, arrowElement, popperConfig = {} }) {
	var _modifiers$eventListe, _modifiers$preventOve, _modifiers$preventOve2, _modifiers$offset, _modifiers$arrow;
	const modifiers = toModifierMap(popperConfig.modifiers);
	return Object.assign({}, popperConfig, {
		placement,
		enabled,
		strategy: fixed ? "fixed" : popperConfig.strategy,
		modifiers: toModifierArray(Object.assign({}, modifiers, {
			eventListeners: {
				enabled: enableEvents,
				options: (_modifiers$eventListe = modifiers.eventListeners) == null ? void 0 : _modifiers$eventListe.options
			},
			preventOverflow: Object.assign({}, modifiers.preventOverflow, { options: containerPadding ? Object.assign({ padding: containerPadding }, (_modifiers$preventOve = modifiers.preventOverflow) == null ? void 0 : _modifiers$preventOve.options) : (_modifiers$preventOve2 = modifiers.preventOverflow) == null ? void 0 : _modifiers$preventOve2.options }),
			offset: { options: Object.assign({ offset: offset$1 }, (_modifiers$offset = modifiers.offset) == null ? void 0 : _modifiers$offset.options) },
			arrow: Object.assign({}, modifiers.arrow, {
				enabled: !!arrowElement,
				options: Object.assign({}, (_modifiers$arrow = modifiers.arrow) == null ? void 0 : _modifiers$arrow.options, { element: arrowElement })
			}),
			flip: Object.assign({ enabled: !!flip$1 }, modifiers.flip)
		}))
	});
}

//#endregion
//#region node_modules/@restart/ui/esm/DropdownMenu.js
var _excluded$2 = ["children", "usePopper"];
function _objectWithoutPropertiesLoose$2(r, e) {
	if (null == r) return {};
	var t = {};
	for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
		if (e.indexOf(n) >= 0) continue;
		t[n] = r[n];
	}
	return t;
}
var noop$3 = () => {};
/**
* @memberOf Dropdown
* @param {object}  options
* @param {boolean} options.flip Automatically adjust the menu `drop` position based on viewport edge detection
* @param {[number, number]} options.offset Define an offset distance between the Menu and the Toggle
* @param {boolean} options.show Display the menu manually, ignored in the context of a `Dropdown`
* @param {boolean} options.usePopper opt in/out of using PopperJS to position menus. When disabled you must position it yourself.
* @param {string}  options.rootCloseEvent The pointer event to listen for when determining "clicks outside" the menu for triggering a close.
* @param {object}  options.popperConfig Options passed to the [`usePopper`](/api/usePopper) hook.
*/
function useDropdownMenu(options = {}) {
	const context$3 = (0, import_react.useContext)(DropdownContext_default$1);
	const [arrowElement, attachArrowRef] = useCallbackRef();
	const hasShownRef = (0, import_react.useRef)(false);
	const { flip: flip$1, offset: offset$1, rootCloseEvent, fixed = false, placement: placementOverride, popperConfig = {}, enableEventListeners = true, usePopper: shouldUsePopper = !!context$3 } = options;
	const show = (context$3 == null ? void 0 : context$3.show) == null ? !!options.show : context$3.show;
	if (show && !hasShownRef.current) hasShownRef.current = true;
	const handleClose = (e) => {
		context$3?.toggle(false, e);
	};
	const { placement, setMenu, menuElement, toggleElement } = context$3 || {};
	const popper$1 = usePopper_default(toggleElement, menuElement, mergeOptionsWithPopperConfig({
		placement: placementOverride || placement || "bottom-start",
		enabled: shouldUsePopper,
		enableEvents: enableEventListeners == null ? show : enableEventListeners,
		offset: offset$1,
		flip: flip$1,
		fixed,
		arrowElement,
		popperConfig
	}));
	const menuProps = Object.assign({
		ref: setMenu || noop$3,
		"aria-labelledby": toggleElement == null ? void 0 : toggleElement.id
	}, popper$1.attributes.popper, { style: popper$1.styles.popper });
	const metadata = {
		show,
		placement,
		hasShown: hasShownRef.current,
		toggle: context$3 == null ? void 0 : context$3.toggle,
		popper: shouldUsePopper ? popper$1 : null,
		arrowProps: shouldUsePopper ? Object.assign({ ref: attachArrowRef }, popper$1.attributes.arrow, { style: popper$1.styles.arrow }) : {}
	};
	useClickOutside_default(menuElement, handleClose, {
		clickTrigger: rootCloseEvent,
		disabled: !show
	});
	return [menuProps, metadata];
}
/**
* Also exported as `<Dropdown.Menu>` from `Dropdown`.
*
* @displayName DropdownMenu
* @memberOf Dropdown
*/
function DropdownMenu$1(_ref) {
	let { children, usePopper: usePopperProp = true } = _ref, options = _objectWithoutPropertiesLoose$2(_ref, _excluded$2);
	const [props, meta] = useDropdownMenu(Object.assign({}, options, { usePopper: usePopperProp }));
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: children(props, meta) });
}
DropdownMenu$1.displayName = "DropdownMenu";
/** @component */
var DropdownMenu_default$1 = DropdownMenu$1;

//#endregion
//#region node_modules/@react-aria/ssr/dist/SSRProvider.mjs
var $b5e257d569688ac6$var$defaultContext = {
	prefix: String(Math.round(Math.random() * 1e10)),
	current: 0
};
var $b5e257d569688ac6$var$SSRContext = /* @__PURE__ */ import_react.createContext($b5e257d569688ac6$var$defaultContext);
var $b5e257d569688ac6$var$IsSSRContext = /* @__PURE__ */ import_react.createContext(false);
function $b5e257d569688ac6$var$LegacySSRProvider(props) {
	let cur = (0, import_react.useContext)($b5e257d569688ac6$var$SSRContext);
	let counter = $b5e257d569688ac6$var$useCounter(cur === $b5e257d569688ac6$var$defaultContext);
	let [isSSR, setIsSSR] = (0, import_react.useState)(true);
	let value = (0, import_react.useMemo)(() => ({
		prefix: cur === $b5e257d569688ac6$var$defaultContext ? "" : `${cur.prefix}-${counter}`,
		current: 0
	}), [cur, counter]);
	if (typeof document !== "undefined") (0, import_react.useLayoutEffect)(() => {
		setIsSSR(false);
	}, []);
	return /* @__PURE__ */ import_react.createElement($b5e257d569688ac6$var$SSRContext.Provider, { value }, /* @__PURE__ */ import_react.createElement($b5e257d569688ac6$var$IsSSRContext.Provider, { value: isSSR }, props.children));
}
var $b5e257d569688ac6$var$warnedAboutSSRProvider = false;
function $b5e257d569688ac6$export$9f8ac96af4b1b2ae(props) {
	if (typeof import_react.useId === "function") {
		if (!$b5e257d569688ac6$var$warnedAboutSSRProvider) {
			console.warn("In React 18, SSRProvider is not necessary and is a noop. You can remove it from your app.");
			$b5e257d569688ac6$var$warnedAboutSSRProvider = true;
		}
		return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, props.children);
	}
	return /* @__PURE__ */ import_react.createElement($b5e257d569688ac6$var$LegacySSRProvider, props);
}
var $b5e257d569688ac6$var$canUseDOM = Boolean(typeof window !== "undefined" && window.document && window.document.createElement);
var $b5e257d569688ac6$var$componentIds = /* @__PURE__ */ new WeakMap();
function $b5e257d569688ac6$var$useCounter(isDisabled = false) {
	let ctx = (0, import_react.useContext)($b5e257d569688ac6$var$SSRContext);
	let ref = (0, import_react.useRef)(null);
	if (ref.current === null && !isDisabled) {
		var _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner, _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
		let currentOwner = (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = import_react.default.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === void 0 ? void 0 : (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner = _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner === void 0 ? void 0 : _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner.current;
		if (currentOwner) {
			let prevComponentValue = $b5e257d569688ac6$var$componentIds.get(currentOwner);
			if (prevComponentValue == null) $b5e257d569688ac6$var$componentIds.set(currentOwner, {
				id: ctx.current,
				state: currentOwner.memoizedState
			});
			else if (currentOwner.memoizedState !== prevComponentValue.state) {
				ctx.current = prevComponentValue.id;
				$b5e257d569688ac6$var$componentIds.delete(currentOwner);
			}
		}
		ref.current = ++ctx.current;
	}
	return ref.current;
}
function $b5e257d569688ac6$var$useLegacySSRSafeId(defaultId) {
	let ctx = (0, import_react.useContext)($b5e257d569688ac6$var$SSRContext);
	if (ctx === $b5e257d569688ac6$var$defaultContext && !$b5e257d569688ac6$var$canUseDOM && true) console.warn("When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.");
	let counter = $b5e257d569688ac6$var$useCounter(!!defaultId);
	let prefix = `react-aria${ctx.prefix}`;
	return defaultId || `${prefix}-${counter}`;
}
function $b5e257d569688ac6$var$useModernSSRSafeId(defaultId) {
	let id = import_react.useId();
	let [didSSR] = (0, import_react.useState)($b5e257d569688ac6$export$535bd6ca7f90a273());
	let prefix = didSSR || false ? "react-aria" : `react-aria${$b5e257d569688ac6$var$defaultContext.prefix}`;
	return defaultId || `${prefix}-${id}`;
}
var $b5e257d569688ac6$export$619500959fc48b26 = typeof import_react.useId === "function" ? $b5e257d569688ac6$var$useModernSSRSafeId : $b5e257d569688ac6$var$useLegacySSRSafeId;
function $b5e257d569688ac6$var$getSnapshot() {
	return false;
}
function $b5e257d569688ac6$var$getServerSnapshot() {
	return true;
}
function $b5e257d569688ac6$var$subscribe(onStoreChange) {
	return () => {};
}
function $b5e257d569688ac6$export$535bd6ca7f90a273() {
	if (typeof import_react.useSyncExternalStore === "function") return import_react.useSyncExternalStore($b5e257d569688ac6$var$subscribe, $b5e257d569688ac6$var$getSnapshot, $b5e257d569688ac6$var$getServerSnapshot);
	return (0, import_react.useContext)($b5e257d569688ac6$var$IsSSRContext);
}

//#endregion
//#region node_modules/@restart/ui/esm/DropdownToggle.js
const isRoleMenu = (el) => {
	var _el$getAttribute;
	return ((_el$getAttribute = el.getAttribute("role")) == null ? void 0 : _el$getAttribute.toLowerCase()) === "menu";
};
var noop$2 = () => {};
/**
* Wires up Dropdown toggle functionality, returning a set a props to attach
* to the element that functions as the dropdown toggle (generally a button).
*
* @memberOf Dropdown
*/
function useDropdownToggle() {
	const id = $b5e257d569688ac6$export$619500959fc48b26();
	const { show = false, toggle = noop$2, setToggle, menuElement } = (0, import_react.useContext)(DropdownContext_default$1) || {};
	const handleClick = (0, import_react.useCallback)((e) => {
		toggle(!show, e);
	}, [show, toggle]);
	const props = {
		id,
		ref: setToggle || noop$2,
		onClick: handleClick,
		"aria-expanded": !!show
	};
	if (menuElement && isRoleMenu(menuElement)) props["aria-haspopup"] = true;
	return [props, {
		show,
		toggle
	}];
}
/**
* Also exported as `<Dropdown.Toggle>` from `Dropdown`.
*
* @displayName DropdownToggle
* @memberOf Dropdown
*/
function DropdownToggle$1({ children }) {
	const [props, meta] = useDropdownToggle();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: children(props, meta) });
}
DropdownToggle$1.displayName = "DropdownToggle";
/** @component */
var DropdownToggle_default$1 = DropdownToggle$1;

//#endregion
//#region node_modules/@restart/ui/esm/DropdownItem.js
var _excluded$1 = [
	"eventKey",
	"disabled",
	"onClick",
	"active",
	"as"
];
function _objectWithoutPropertiesLoose$1(r, e) {
	if (null == r) return {};
	var t = {};
	for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
		if (e.indexOf(n) >= 0) continue;
		t[n] = r[n];
	}
	return t;
}
/**
* Create a dropdown item. Returns a set of props for the dropdown item component
* including an `onClick` handler that prevents selection when the item is disabled
*/
function useDropdownItem({ key, href, active, disabled, onClick }) {
	const onSelectCtx = (0, import_react.useContext)(SelectableContext_default);
	const { activeKey } = (0, import_react.useContext)(NavContext_default) || {};
	const eventKey = makeEventKey(key, href);
	const isActive = active == null && key != null ? makeEventKey(activeKey) === eventKey : active;
	return [{
		onClick: useEventCallback$1((event) => {
			if (disabled) return;
			onClick?.(event);
			if (onSelectCtx && !event.isPropagationStopped()) onSelectCtx(eventKey, event);
		}),
		"aria-disabled": disabled || void 0,
		"aria-selected": isActive,
		[dataAttr("dropdown-item")]: ""
	}, { isActive }];
}
var DropdownItem$1 = /* @__PURE__ */ import_react.forwardRef((_ref, ref) => {
	let { eventKey, disabled, onClick, active, as: Component = Button_default$1 } = _ref, props = _objectWithoutPropertiesLoose$1(_ref, _excluded$1);
	const [dropdownItemProps] = useDropdownItem({
		key: eventKey,
		href: props.href,
		disabled,
		onClick,
		active
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, Object.assign({}, props, { ref }, dropdownItemProps));
});
DropdownItem$1.displayName = "DropdownItem";
var DropdownItem_default$1 = DropdownItem$1;

//#endregion
//#region node_modules/@restart/ui/esm/Dropdown.js
function useRefWithUpdate() {
	const forceUpdate = useForceUpdate();
	const ref = (0, import_react.useRef)(null);
	const attachRef = (0, import_react.useCallback)((element) => {
		ref.current = element;
		forceUpdate();
	}, [forceUpdate]);
	return [ref, attachRef];
}
/**
* @displayName Dropdown
* @public
*/
function Dropdown$1({ defaultShow, show: rawShow, onSelect, onToggle: rawOnToggle, itemSelector = `* [${dataAttr("dropdown-item")}]`, focusFirstItemOnShow, placement = "bottom-start", children }) {
	const window$1 = useWindow();
	const [show, onToggle] = useUncontrolledProp(rawShow, defaultShow, rawOnToggle);
	const [menuRef, setMenu] = useRefWithUpdate();
	const menuElement = menuRef.current;
	const [toggleRef, setToggle] = useRefWithUpdate();
	const toggleElement = toggleRef.current;
	const lastShow = usePrevious(show);
	const lastSourceEvent = (0, import_react.useRef)(null);
	const focusInDropdown = (0, import_react.useRef)(false);
	const onSelectCtx = (0, import_react.useContext)(SelectableContext_default);
	const toggle = (0, import_react.useCallback)((nextShow, event, source = event == null ? void 0 : event.type) => {
		onToggle(nextShow, {
			originalEvent: event,
			source
		});
	}, [onToggle]);
	const handleSelect = useEventCallback$1((key, event) => {
		onSelect?.(key, event);
		toggle(false, event, "select");
		if (!event.isPropagationStopped()) onSelectCtx?.(key, event);
	});
	const context$3 = (0, import_react.useMemo)(() => ({
		toggle,
		placement,
		show,
		menuElement,
		toggleElement,
		setMenu,
		setToggle
	}), [
		toggle,
		placement,
		show,
		menuElement,
		toggleElement,
		setMenu,
		setToggle
	]);
	if (menuElement && lastShow && !show) focusInDropdown.current = menuElement.contains(menuElement.ownerDocument.activeElement);
	const focusToggle = useEventCallback$1(() => {
		if (toggleElement && toggleElement.focus) toggleElement.focus();
	});
	const maybeFocusFirst = useEventCallback$1(() => {
		const type = lastSourceEvent.current;
		let focusType = focusFirstItemOnShow;
		if (focusType == null) focusType = menuRef.current && isRoleMenu(menuRef.current) ? "keyboard" : false;
		if (focusType === false || focusType === "keyboard" && !/^key.+$/.test(type)) return;
		const first = qsa(menuRef.current, itemSelector)[0];
		if (first && first.focus) first.focus();
	});
	(0, import_react.useEffect)(() => {
		if (show) maybeFocusFirst();
		else if (focusInDropdown.current) {
			focusInDropdown.current = false;
			focusToggle();
		}
	}, [
		show,
		focusInDropdown,
		focusToggle,
		maybeFocusFirst
	]);
	(0, import_react.useEffect)(() => {
		lastSourceEvent.current = null;
	});
	const getNextFocusedChild = (current, offset$1) => {
		if (!menuRef.current) return null;
		const items = qsa(menuRef.current, itemSelector);
		let index = items.indexOf(current) + offset$1;
		index = Math.max(0, Math.min(index, items.length));
		return items[index];
	};
	useEventListener((0, import_react.useCallback)(() => window$1.document, [window$1]), "keydown", (event) => {
		var _menuRef$current, _toggleRef$current;
		const { key } = event;
		const target = event.target;
		const fromMenu = (_menuRef$current = menuRef.current) == null ? void 0 : _menuRef$current.contains(target);
		const fromToggle = (_toggleRef$current = toggleRef.current) == null ? void 0 : _toggleRef$current.contains(target);
		if (/input|textarea/i.test(target.tagName) && (key === " " || key !== "Escape" && fromMenu || key === "Escape" && target.type === "search")) return;
		if (!fromMenu && !fromToggle) return;
		if (key === "Tab" && (!menuRef.current || !show)) return;
		lastSourceEvent.current = event.type;
		const meta = {
			originalEvent: event,
			source: event.type
		};
		switch (key) {
			case "ArrowUp": {
				const next = getNextFocusedChild(target, -1);
				if (next && next.focus) next.focus();
				event.preventDefault();
				return;
			}
			case "ArrowDown":
				event.preventDefault();
				if (!show) onToggle(true, meta);
				else {
					const next = getNextFocusedChild(target, 1);
					if (next && next.focus) next.focus();
				}
				return;
			case "Tab":
				addEventListener_default(target.ownerDocument, "keyup", (e) => {
					var _menuRef$current2;
					if (e.key === "Tab" && !e.target || !((_menuRef$current2 = menuRef.current) != null && _menuRef$current2.contains(e.target))) onToggle(false, meta);
				}, { once: true });
				break;
			case "Escape":
				if (key === "Escape") {
					event.preventDefault();
					event.stopPropagation();
				}
				onToggle(false, meta);
				break;
			default:
		}
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SelectableContext_default.Provider, {
		value: handleSelect,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DropdownContext_default$1.Provider, {
			value: context$3,
			children
		})
	});
}
Dropdown$1.displayName = "Dropdown";
Dropdown$1.Menu = DropdownMenu_default$1;
Dropdown$1.Toggle = DropdownToggle_default$1;
Dropdown$1.Item = DropdownItem_default$1;
var Dropdown_default$1 = Dropdown$1;

//#endregion
//#region node_modules/react-bootstrap/esm/DropdownContext.js
var DropdownContext = /* @__PURE__ */ import_react.createContext({});
DropdownContext.displayName = "DropdownContext";
var DropdownContext_default = DropdownContext;

//#endregion
//#region node_modules/react-bootstrap/esm/DropdownDivider.js
var import_classnames$54 = /* @__PURE__ */ __toESM(require_classnames());
var DropdownDivider = /* @__PURE__ */ import_react.forwardRef(({ className, bsPrefix, as: Component = "hr", role = "separator",...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "dropdown-divider");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		className: (0, import_classnames$54.default)(className, bsPrefix),
		role,
		...props
	});
});
DropdownDivider.displayName = "DropdownDivider";
var DropdownDivider_default = DropdownDivider;

//#endregion
//#region node_modules/react-bootstrap/esm/DropdownHeader.js
var import_classnames$53 = /* @__PURE__ */ __toESM(require_classnames());
var DropdownHeader = /* @__PURE__ */ import_react.forwardRef(({ className, bsPrefix, as: Component = "div", role = "heading",...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "dropdown-header");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		className: (0, import_classnames$53.default)(className, bsPrefix),
		role,
		...props
	});
});
DropdownHeader.displayName = "DropdownHeader";
var DropdownHeader_default = DropdownHeader;

//#endregion
//#region node_modules/react-bootstrap/esm/DropdownItem.js
var import_classnames$52 = /* @__PURE__ */ __toESM(require_classnames());
var DropdownItem = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, className, eventKey, disabled = false, onClick, active, as: Component = Anchor_default$1,...props }, ref) => {
	const prefix = useBootstrapPrefix(bsPrefix, "dropdown-item");
	const [dropdownItemProps, meta] = useDropdownItem({
		key: eventKey,
		href: props.href,
		disabled,
		onClick,
		active
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		...props,
		...dropdownItemProps,
		ref,
		className: (0, import_classnames$52.default)(className, prefix, meta.isActive && "active", disabled && "disabled")
	});
});
DropdownItem.displayName = "DropdownItem";
var DropdownItem_default = DropdownItem;

//#endregion
//#region node_modules/react-bootstrap/esm/DropdownItemText.js
var import_classnames$51 = /* @__PURE__ */ __toESM(require_classnames());
var DropdownItemText = /* @__PURE__ */ import_react.forwardRef(({ className, bsPrefix, as: Component = "span",...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "dropdown-item-text");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		className: (0, import_classnames$51.default)(className, bsPrefix),
		...props
	});
});
DropdownItemText.displayName = "DropdownItemText";
var DropdownItemText_default = DropdownItemText;

//#endregion
//#region node_modules/react-bootstrap/esm/InputGroupContext.js
var context = /* @__PURE__ */ import_react.createContext(null);
context.displayName = "InputGroupContext";
var InputGroupContext_default = context;

//#endregion
//#region node_modules/react-bootstrap/esm/useWrappedRefWithWarning.js
var import_browser$1 = /* @__PURE__ */ __toESM(require_browser());
function useWrappedRefWithWarning(ref, componentName) {
	const warningRef = (0, import_react.useCallback)((refValue) => {
		!(refValue == null || !refValue.isReactComponent) && (0, import_browser$1.default)(false, `${componentName} injected a ref to a provided \`as\` component that resolved to a component instance instead of a DOM element. Use \`React.forwardRef\` to provide the injected ref to the class component as a prop in order to pass it directly to a DOM element`);
	}, [componentName]);
	return useMergedRefs_default(warningRef, ref);
}

//#endregion
//#region node_modules/react-bootstrap/esm/types.js
var import_prop_types$8 = /* @__PURE__ */ __toESM(require_prop_types());
var alignDirection = import_prop_types$8.default.oneOf(["start", "end"]);
const alignPropType = import_prop_types$8.default.oneOfType([
	alignDirection,
	import_prop_types$8.default.shape({ sm: alignDirection }),
	import_prop_types$8.default.shape({ md: alignDirection }),
	import_prop_types$8.default.shape({ lg: alignDirection }),
	import_prop_types$8.default.shape({ xl: alignDirection }),
	import_prop_types$8.default.shape({ xxl: alignDirection }),
	import_prop_types$8.default.object
]);

//#endregion
//#region node_modules/react-bootstrap/esm/DropdownMenu.js
var import_classnames$50 = /* @__PURE__ */ __toESM(require_classnames());
var import_warning$5 = /* @__PURE__ */ __toESM(require_warning());
function getDropdownMenuPlacement(alignEnd, dropDirection, isRTL) {
	const topStart = isRTL ? "top-end" : "top-start";
	const topEnd = isRTL ? "top-start" : "top-end";
	const bottomStart = isRTL ? "bottom-end" : "bottom-start";
	const bottomEnd = isRTL ? "bottom-start" : "bottom-end";
	const leftStart = isRTL ? "right-start" : "left-start";
	const leftEnd = isRTL ? "right-end" : "left-end";
	const rightStart = isRTL ? "left-start" : "right-start";
	const rightEnd = isRTL ? "left-end" : "right-end";
	let placement = alignEnd ? bottomEnd : bottomStart;
	if (dropDirection === "up") placement = alignEnd ? topEnd : topStart;
	else if (dropDirection === "end") placement = alignEnd ? rightEnd : rightStart;
	else if (dropDirection === "start") placement = alignEnd ? leftEnd : leftStart;
	else if (dropDirection === "down-centered") placement = "bottom";
	else if (dropDirection === "up-centered") placement = "top";
	return placement;
}
var DropdownMenu = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, className, align, rootCloseEvent, flip: flip$1 = true, show: showProps, renderOnMount, as: Component = "div", popperConfig, variant,...props }, ref) => {
	let alignEnd = false;
	const isNavbar = (0, import_react.useContext)(NavbarContext_default);
	const prefix = useBootstrapPrefix(bsPrefix, "dropdown-menu");
	const { align: contextAlign, drop, isRTL } = (0, import_react.useContext)(DropdownContext_default);
	align = align || contextAlign;
	const isInputGroup = (0, import_react.useContext)(InputGroupContext_default);
	const alignClasses = [];
	if (align) {
		if (typeof align === "object") {
			const keys = Object.keys(align);
			(0, import_warning$5.default)(keys.length === 1, "There should only be 1 breakpoint when passing an object to `align`");
			if (keys.length) {
				const brkPoint = keys[0];
				const direction = align[brkPoint];
				alignEnd = direction === "start";
				alignClasses.push(`${prefix}-${brkPoint}-${direction}`);
			}
		} else if (align === "end") alignEnd = true;
	}
	const placement = getDropdownMenuPlacement(alignEnd, drop, isRTL);
	const [menuProps, { hasShown, popper: popper$1, show, toggle }] = useDropdownMenu({
		flip: flip$1,
		rootCloseEvent,
		show: showProps,
		usePopper: !isNavbar && alignClasses.length === 0,
		offset: [0, 2],
		popperConfig,
		placement
	});
	menuProps.ref = useMergedRefs_default(useWrappedRefWithWarning(ref, "DropdownMenu"), menuProps.ref);
	useIsomorphicEffect_default(() => {
		if (show) popper$1?.update();
	}, [show]);
	if (!hasShown && !renderOnMount && !isInputGroup) return null;
	if (typeof Component !== "string") {
		menuProps.show = show;
		menuProps.close = () => toggle == null ? void 0 : toggle(false);
		menuProps.align = align;
	}
	let style = props.style;
	if (popper$1 != null && popper$1.placement) {
		style = {
			...props.style,
			...menuProps.style
		};
		props["x-placement"] = popper$1.placement;
	}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		...props,
		...menuProps,
		style,
		...(alignClasses.length || isNavbar) && { "data-bs-popper": "static" },
		className: (0, import_classnames$50.default)(className, prefix, show && "show", alignEnd && `${prefix}-end`, variant && `${prefix}-${variant}`, ...alignClasses)
	});
});
DropdownMenu.displayName = "DropdownMenu";
var DropdownMenu_default = DropdownMenu;

//#endregion
//#region node_modules/react-bootstrap/esm/DropdownToggle.js
var import_classnames$49 = /* @__PURE__ */ __toESM(require_classnames());
var DropdownToggle = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, split, className, childBsPrefix, as: Component = Button_default,...props }, ref) => {
	const prefix = useBootstrapPrefix(bsPrefix, "dropdown-toggle");
	const dropdownContext = (0, import_react.useContext)(DropdownContext_default$1);
	if (childBsPrefix !== void 0) props.bsPrefix = childBsPrefix;
	const [toggleProps] = useDropdownToggle();
	toggleProps.ref = useMergedRefs_default(toggleProps.ref, useWrappedRefWithWarning(ref, "DropdownToggle"));
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		className: (0, import_classnames$49.default)(className, prefix, split && `${prefix}-split`, (dropdownContext == null ? void 0 : dropdownContext.show) && "show"),
		...toggleProps,
		...props
	});
});
DropdownToggle.displayName = "DropdownToggle";
var DropdownToggle_default = DropdownToggle;

//#endregion
//#region node_modules/react-bootstrap/esm/Dropdown.js
var import_classnames$48 = /* @__PURE__ */ __toESM(require_classnames());
var Dropdown = /* @__PURE__ */ import_react.forwardRef((pProps, ref) => {
	const { bsPrefix, drop = "down", show, className, align = "start", onSelect, onToggle, focusFirstItemOnShow, as: Component = "div", navbar: _4, autoClose = true,...props } = useUncontrolled(pProps, { show: "onToggle" });
	const isInputGroup = (0, import_react.useContext)(InputGroupContext_default);
	const prefix = useBootstrapPrefix(bsPrefix, "dropdown");
	const isRTL = useIsRTL();
	const isClosingPermitted = (source) => {
		if (autoClose === false) return source === "click";
		if (autoClose === "inside") return source !== "rootClose";
		if (autoClose === "outside") return source !== "select";
		return true;
	};
	const handleToggle = useEventCallback((nextShow, meta) => {
		var _meta$originalEvent;
		if (((_meta$originalEvent = meta.originalEvent) == null || (_meta$originalEvent = _meta$originalEvent.target) == null ? void 0 : _meta$originalEvent.classList.contains("dropdown-toggle")) && meta.source === "mousedown") return;
		if (meta.originalEvent.currentTarget === document && (meta.source !== "keydown" || meta.originalEvent.key === "Escape")) meta.source = "rootClose";
		if (isClosingPermitted(meta.source)) onToggle?.(nextShow, meta);
	});
	const placement = getDropdownMenuPlacement(align === "end", drop, isRTL);
	const contextValue = (0, import_react.useMemo)(() => ({
		align,
		drop,
		isRTL
	}), [
		align,
		drop,
		isRTL
	]);
	const directionClasses = {
		down: prefix,
		"down-centered": `${prefix}-center`,
		up: "dropup",
		"up-centered": "dropup-center dropup",
		end: "dropend",
		start: "dropstart"
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DropdownContext_default.Provider, {
		value: contextValue,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Dropdown_default$1, {
			placement,
			show,
			onSelect,
			onToggle: handleToggle,
			focusFirstItemOnShow,
			itemSelector: `.${prefix}-item:not(.disabled):not(:disabled)`,
			children: isInputGroup ? props.children : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
				...props,
				ref,
				className: (0, import_classnames$48.default)(className, show && "show", directionClasses[drop])
			})
		})
	});
});
Dropdown.displayName = "Dropdown";
var Dropdown_default = Object.assign(Dropdown, {
	Toggle: DropdownToggle_default,
	Menu: DropdownMenu_default,
	Item: DropdownItem_default,
	ItemText: DropdownItemText_default,
	Divider: DropdownDivider_default,
	Header: DropdownHeader_default
});

//#endregion
//#region node_modules/react-bootstrap/esm/DropdownButton.js
var import_prop_types$7 = /* @__PURE__ */ __toESM(require_prop_types());
var propTypes$5 = {
	id: import_prop_types$7.default.string,
	href: import_prop_types$7.default.string,
	onClick: import_prop_types$7.default.func,
	title: import_prop_types$7.default.node.isRequired,
	disabled: import_prop_types$7.default.bool,
	align: alignPropType,
	menuRole: import_prop_types$7.default.string,
	renderMenuOnMount: import_prop_types$7.default.bool,
	rootCloseEvent: import_prop_types$7.default.string,
	menuVariant: import_prop_types$7.default.oneOf(["dark"]),
	flip: import_prop_types$7.default.bool,
	bsPrefix: import_prop_types$7.default.string,
	variant: import_prop_types$7.default.string,
	size: import_prop_types$7.default.string
};
/**
* A convenience component for simple or general use dropdowns. Renders a `Button` toggle and all `children`
* are passed directly to the default `Dropdown.Menu`. This component accepts all of
* [`Dropdown`'s props](#dropdown-props).
*
* _All unknown props are passed through to the `Dropdown` component._ Only
* the Button `variant`, `size` and `bsPrefix` props are passed to the toggle,
* along with menu-related props are passed to the `Dropdown.Menu`
*/
var DropdownButton = /* @__PURE__ */ import_react.forwardRef(({ title, children, bsPrefix, rootCloseEvent, variant, size: size$1, menuRole, renderMenuOnMount, disabled, href, id, menuVariant, flip: flip$1,...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Dropdown_default, {
	ref,
	...props,
	children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(DropdownToggle_default, {
		id,
		href,
		size: size$1,
		variant,
		disabled,
		childBsPrefix: bsPrefix,
		children: title
	}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DropdownMenu_default, {
		role: menuRole,
		renderOnMount: renderMenuOnMount,
		rootCloseEvent,
		variant: menuVariant,
		flip: flip$1,
		children
	})]
}));
DropdownButton.displayName = "DropdownButton";
DropdownButton.propTypes = propTypes$5;
var DropdownButton_default = DropdownButton;

//#endregion
//#region node_modules/react-bootstrap/esm/Image.js
var import_classnames$47 = /* @__PURE__ */ __toESM(require_classnames());
var import_prop_types$6 = /* @__PURE__ */ __toESM(require_prop_types());
const propTypes$4 = {
	bsPrefix: import_prop_types$6.default.string,
	fluid: import_prop_types$6.default.bool,
	rounded: import_prop_types$6.default.bool,
	roundedCircle: import_prop_types$6.default.bool,
	thumbnail: import_prop_types$6.default.bool
};
var Image = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, className, fluid = false, rounded = false, roundedCircle = false, thumbnail = false,...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "img");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("img", {
		ref,
		...props,
		className: (0, import_classnames$47.default)(className, fluid && `${bsPrefix}-fluid`, rounded && `rounded`, roundedCircle && `rounded-circle`, thumbnail && `${bsPrefix}-thumbnail`)
	});
});
Image.displayName = "Image";
var Image_default = Image;

//#endregion
//#region node_modules/react-bootstrap/esm/FigureImage.js
var import_classnames$46 = /* @__PURE__ */ __toESM(require_classnames());
var FigureImage = /* @__PURE__ */ import_react.forwardRef(({ className, fluid = true,...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Image_default, {
	ref,
	...props,
	fluid,
	className: (0, import_classnames$46.default)(className, "figure-img")
}));
FigureImage.displayName = "FigureImage";
FigureImage.propTypes = propTypes$4;
var FigureImage_default = FigureImage;

//#endregion
//#region node_modules/react-bootstrap/esm/FigureCaption.js
var import_classnames$45 = /* @__PURE__ */ __toESM(require_classnames());
var FigureCaption = /* @__PURE__ */ import_react.forwardRef(({ className, bsPrefix, as: Component = "figcaption",...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "figure-caption");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		className: (0, import_classnames$45.default)(className, bsPrefix),
		...props
	});
});
FigureCaption.displayName = "FigureCaption";
var FigureCaption_default = FigureCaption;

//#endregion
//#region node_modules/react-bootstrap/esm/Figure.js
var import_classnames$44 = /* @__PURE__ */ __toESM(require_classnames());
var Figure = /* @__PURE__ */ import_react.forwardRef(({ className, bsPrefix, as: Component = "figure",...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "figure");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		className: (0, import_classnames$44.default)(className, bsPrefix),
		...props
	});
});
Figure.displayName = "Figure";
var Figure_default = Object.assign(Figure, {
	Image: FigureImage_default,
	Caption: FigureCaption_default
});

//#endregion
//#region node_modules/react-bootstrap/esm/Feedback.js
var import_classnames$43 = /* @__PURE__ */ __toESM(require_classnames());
var import_prop_types$5 = /* @__PURE__ */ __toESM(require_prop_types());
var propTypes$3 = {
	type: import_prop_types$5.default.string,
	tooltip: import_prop_types$5.default.bool,
	as: import_prop_types$5.default.elementType
};
var Feedback = /* @__PURE__ */ import_react.forwardRef(({ as: Component = "div", className, type = "valid", tooltip = false,...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
	...props,
	ref,
	className: (0, import_classnames$43.default)(className, `${type}-${tooltip ? "tooltip" : "feedback"}`)
}));
Feedback.displayName = "Feedback";
Feedback.propTypes = propTypes$3;
var Feedback_default = Feedback;

//#endregion
//#region node_modules/react-bootstrap/esm/FormContext.js
var FormContext = /* @__PURE__ */ import_react.createContext({});
var FormContext_default = FormContext;

//#endregion
//#region node_modules/react-bootstrap/esm/FormCheckInput.js
var import_classnames$42 = /* @__PURE__ */ __toESM(require_classnames());
var FormCheckInput = /* @__PURE__ */ import_react.forwardRef(({ id, bsPrefix, className, type = "checkbox", isValid = false, isInvalid = false, as: Component = "input",...props }, ref) => {
	const { controlId } = (0, import_react.useContext)(FormContext_default);
	bsPrefix = useBootstrapPrefix(bsPrefix, "form-check-input");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		...props,
		ref,
		type,
		id: id || controlId,
		className: (0, import_classnames$42.default)(className, bsPrefix, isValid && "is-valid", isInvalid && "is-invalid")
	});
});
FormCheckInput.displayName = "FormCheckInput";
var FormCheckInput_default = FormCheckInput;

//#endregion
//#region node_modules/react-bootstrap/esm/FormCheckLabel.js
var import_classnames$41 = /* @__PURE__ */ __toESM(require_classnames());
var FormCheckLabel = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, className, htmlFor,...props }, ref) => {
	const { controlId } = (0, import_react.useContext)(FormContext_default);
	bsPrefix = useBootstrapPrefix(bsPrefix, "form-check-label");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("label", {
		...props,
		ref,
		htmlFor: htmlFor || controlId,
		className: (0, import_classnames$41.default)(className, bsPrefix)
	});
});
FormCheckLabel.displayName = "FormCheckLabel";
var FormCheckLabel_default = FormCheckLabel;

//#endregion
//#region node_modules/react-bootstrap/esm/FormCheck.js
var import_classnames$40 = /* @__PURE__ */ __toESM(require_classnames());
var FormCheck = /* @__PURE__ */ import_react.forwardRef(({ id, bsPrefix, bsSwitchPrefix, inline = false, reverse = false, disabled = false, isValid = false, isInvalid = false, feedbackTooltip = false, feedback, feedbackType, className, style, title = "", type = "checkbox", label, children, as = "input",...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "form-check");
	bsSwitchPrefix = useBootstrapPrefix(bsSwitchPrefix, "form-switch");
	const { controlId } = (0, import_react.useContext)(FormContext_default);
	const innerFormContext = (0, import_react.useMemo)(() => ({ controlId: id || controlId }), [controlId, id]);
	const hasLabel = !children && label != null && label !== false || hasChildOfType(children, FormCheckLabel_default);
	const input = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormCheckInput_default, {
		...props,
		type: type === "switch" ? "checkbox" : type,
		ref,
		isValid,
		isInvalid,
		disabled,
		as
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormContext_default.Provider, {
		value: innerFormContext,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			style,
			className: (0, import_classnames$40.default)(className, hasLabel && bsPrefix, inline && `${bsPrefix}-inline`, reverse && `${bsPrefix}-reverse`, type === "switch" && bsSwitchPrefix),
			children: children || /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
				input,
				hasLabel && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormCheckLabel_default, {
					title,
					children: label
				}),
				feedback && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Feedback_default, {
					type: feedbackType,
					tooltip: feedbackTooltip,
					children: feedback
				})
			] })
		})
	});
});
FormCheck.displayName = "FormCheck";
var FormCheck_default = Object.assign(FormCheck, {
	Input: FormCheckInput_default,
	Label: FormCheckLabel_default
});

//#endregion
//#region node_modules/react-bootstrap/esm/FormControl.js
var import_classnames$39 = /* @__PURE__ */ __toESM(require_classnames());
var import_warning$4 = /* @__PURE__ */ __toESM(require_warning());
var FormControl = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, type, size: size$1, htmlSize, id, className, isValid = false, isInvalid = false, plaintext, readOnly, as: Component = "input",...props }, ref) => {
	const { controlId } = (0, import_react.useContext)(FormContext_default);
	bsPrefix = useBootstrapPrefix(bsPrefix, "form-control");
	(0, import_warning$4.default)(controlId == null || !id, "`controlId` is ignored on `<FormControl>` when `id` is specified.");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		...props,
		type,
		size: htmlSize,
		ref,
		readOnly,
		id: id || controlId,
		className: (0, import_classnames$39.default)(className, plaintext ? `${bsPrefix}-plaintext` : bsPrefix, size$1 && `${bsPrefix}-${size$1}`, type === "color" && `${bsPrefix}-color`, isValid && "is-valid", isInvalid && "is-invalid")
	});
});
FormControl.displayName = "FormControl";
var FormControl_default = Object.assign(FormControl, { Feedback: Feedback_default });

//#endregion
//#region node_modules/react-bootstrap/esm/FormFloating.js
var import_classnames$38 = /* @__PURE__ */ __toESM(require_classnames());
var FormFloating = /* @__PURE__ */ import_react.forwardRef(({ className, bsPrefix, as: Component = "div",...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "form-floating");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		className: (0, import_classnames$38.default)(className, bsPrefix),
		...props
	});
});
FormFloating.displayName = "FormFloating";
var FormFloating_default = FormFloating;

//#endregion
//#region node_modules/react-bootstrap/esm/FormGroup.js
var FormGroup = /* @__PURE__ */ import_react.forwardRef(({ controlId, as: Component = "div",...props }, ref) => {
	const context$3 = (0, import_react.useMemo)(() => ({ controlId }), [controlId]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormContext_default.Provider, {
		value: context$3,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
			...props,
			ref
		})
	});
});
FormGroup.displayName = "FormGroup";
var FormGroup_default = FormGroup;

//#endregion
//#region node_modules/react-bootstrap/esm/FormLabel.js
var import_classnames$37 = /* @__PURE__ */ __toESM(require_classnames());
var import_warning$3 = /* @__PURE__ */ __toESM(require_warning());
var FormLabel = /* @__PURE__ */ import_react.forwardRef(({ as: Component = "label", bsPrefix, column = false, visuallyHidden = false, className, htmlFor,...props }, ref) => {
	const { controlId } = (0, import_react.useContext)(FormContext_default);
	bsPrefix = useBootstrapPrefix(bsPrefix, "form-label");
	let columnClass = "col-form-label";
	if (typeof column === "string") columnClass = `${columnClass} ${columnClass}-${column}`;
	const classes = (0, import_classnames$37.default)(className, bsPrefix, visuallyHidden && "visually-hidden", column && columnClass);
	(0, import_warning$3.default)(controlId == null || !htmlFor, "`controlId` is ignored on `<FormLabel>` when `htmlFor` is specified.");
	htmlFor = htmlFor || controlId;
	if (column) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Col_default, {
		ref,
		as: "label",
		className: classes,
		htmlFor,
		...props
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		className: classes,
		htmlFor,
		...props
	});
});
FormLabel.displayName = "FormLabel";
var FormLabel_default = FormLabel;

//#endregion
//#region node_modules/react-bootstrap/esm/FormRange.js
var import_classnames$36 = /* @__PURE__ */ __toESM(require_classnames());
var FormRange = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, className, id,...props }, ref) => {
	const { controlId } = (0, import_react.useContext)(FormContext_default);
	bsPrefix = useBootstrapPrefix(bsPrefix, "form-range");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("input", {
		...props,
		type: "range",
		ref,
		className: (0, import_classnames$36.default)(className, bsPrefix),
		id: id || controlId
	});
});
FormRange.displayName = "FormRange";
var FormRange_default = FormRange;

//#endregion
//#region node_modules/react-bootstrap/esm/FormSelect.js
var import_classnames$35 = /* @__PURE__ */ __toESM(require_classnames());
var FormSelect = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, size: size$1, htmlSize, className, isValid = false, isInvalid = false, id,...props }, ref) => {
	const { controlId } = (0, import_react.useContext)(FormContext_default);
	bsPrefix = useBootstrapPrefix(bsPrefix, "form-select");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("select", {
		...props,
		size: htmlSize,
		ref,
		className: (0, import_classnames$35.default)(className, bsPrefix, size$1 && `${bsPrefix}-${size$1}`, isValid && `is-valid`, isInvalid && `is-invalid`),
		id: id || controlId
	});
});
FormSelect.displayName = "FormSelect";
var FormSelect_default = FormSelect;

//#endregion
//#region node_modules/react-bootstrap/esm/FormText.js
var import_classnames$34 = /* @__PURE__ */ __toESM(require_classnames());
var FormText = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, className, as: Component = "small", muted,...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "form-text");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		...props,
		ref,
		className: (0, import_classnames$34.default)(className, bsPrefix, muted && "text-muted")
	});
});
FormText.displayName = "FormText";
var FormText_default = FormText;

//#endregion
//#region node_modules/react-bootstrap/esm/Switch.js
var Switch = /* @__PURE__ */ import_react.forwardRef((props, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormCheck_default, {
	...props,
	ref,
	type: "switch"
}));
Switch.displayName = "Switch";
var Switch_default = Object.assign(Switch, {
	Input: FormCheck_default.Input,
	Label: FormCheck_default.Label
});

//#endregion
//#region node_modules/react-bootstrap/esm/FloatingLabel.js
var import_classnames$33 = /* @__PURE__ */ __toESM(require_classnames());
var FloatingLabel = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, className, children, controlId, label,...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "form-floating");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(FormGroup_default, {
		ref,
		className: (0, import_classnames$33.default)(className, bsPrefix),
		controlId,
		...props,
		children: [children, /* @__PURE__ */ (0, import_jsx_runtime.jsx)("label", {
			htmlFor: controlId,
			children: label
		})]
	});
});
FloatingLabel.displayName = "FloatingLabel";
var FloatingLabel_default = FloatingLabel;

//#endregion
//#region node_modules/react-bootstrap/esm/Form.js
var import_classnames$32 = /* @__PURE__ */ __toESM(require_classnames());
var import_prop_types$4 = /* @__PURE__ */ __toESM(require_prop_types());
var propTypes$2 = {
	_ref: import_prop_types$4.default.any,
	validated: import_prop_types$4.default.bool,
	as: import_prop_types$4.default.elementType
};
var Form = /* @__PURE__ */ import_react.forwardRef(({ className, validated, as: Component = "form",...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
	...props,
	ref,
	className: (0, import_classnames$32.default)(className, validated && "was-validated")
}));
Form.displayName = "Form";
Form.propTypes = propTypes$2;
var Form_default = Object.assign(Form, {
	Group: FormGroup_default,
	Control: FormControl_default,
	Floating: FormFloating_default,
	Check: FormCheck_default,
	Switch: Switch_default,
	Label: FormLabel_default,
	Text: FormText_default,
	Range: FormRange_default,
	Select: FormSelect_default,
	FloatingLabel: FloatingLabel_default
});

//#endregion
//#region node_modules/react-bootstrap/esm/InputGroupText.js
var import_classnames$31 = /* @__PURE__ */ __toESM(require_classnames());
var InputGroupText = /* @__PURE__ */ import_react.forwardRef(({ className, bsPrefix, as: Component = "span",...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "input-group-text");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		className: (0, import_classnames$31.default)(className, bsPrefix),
		...props
	});
});
InputGroupText.displayName = "InputGroupText";
var InputGroupText_default = InputGroupText;

//#endregion
//#region node_modules/react-bootstrap/esm/InputGroup.js
var import_classnames$30 = /* @__PURE__ */ __toESM(require_classnames());
var InputGroupCheckbox = (props) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InputGroupText_default, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormCheckInput_default, {
	type: "checkbox",
	...props
}) });
var InputGroupRadio = (props) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InputGroupText_default, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(FormCheckInput_default, {
	type: "radio",
	...props
}) });
var InputGroup = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, size: size$1, hasValidation, className, as: Component = "div",...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "input-group");
	const contextValue = (0, import_react.useMemo)(() => ({}), []);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InputGroupContext_default.Provider, {
		value: contextValue,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
			ref,
			...props,
			className: (0, import_classnames$30.default)(className, bsPrefix, size$1 && `${bsPrefix}-${size$1}`, hasValidation && "has-validation")
		})
	});
});
InputGroup.displayName = "InputGroup";
var InputGroup_default = Object.assign(InputGroup, {
	Text: InputGroupText_default,
	Radio: InputGroupRadio,
	Checkbox: InputGroupCheckbox
});

//#endregion
//#region node_modules/react-bootstrap/esm/ListGroupItem.js
var import_classnames$29 = /* @__PURE__ */ __toESM(require_classnames());
var import_warning$2 = /* @__PURE__ */ __toESM(require_warning());
var ListGroupItem = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, active, disabled, eventKey, className, variant, action, as,...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "list-group-item");
	const [navItemProps, meta] = useNavItem({
		key: makeEventKey(eventKey, props.href),
		active,
		...props
	});
	const handleClick = useEventCallback((event) => {
		if (disabled) {
			event.preventDefault();
			event.stopPropagation();
			return;
		}
		navItemProps.onClick(event);
	});
	if (disabled && props.tabIndex === void 0) {
		props.tabIndex = -1;
		props["aria-disabled"] = true;
	}
	const Component = as || (action ? props.href ? "a" : "button" : "div");
	(0, import_warning$2.default)(as || !(!action && props.href), "`action=false` and `href` should not be used together.");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		...props,
		...navItemProps,
		onClick: handleClick,
		className: (0, import_classnames$29.default)(className, bsPrefix, meta.isActive && "active", disabled && "disabled", variant && `${bsPrefix}-${variant}`, action && `${bsPrefix}-action`)
	});
});
ListGroupItem.displayName = "ListGroupItem";
var ListGroupItem_default = ListGroupItem;

//#endregion
//#region node_modules/react-bootstrap/esm/ListGroup.js
var import_classnames$28 = /* @__PURE__ */ __toESM(require_classnames());
var import_warning$1 = /* @__PURE__ */ __toESM(require_warning());
var ListGroup = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { className, bsPrefix: initialBsPrefix, variant, horizontal, numbered, as = "div",...controlledProps } = useUncontrolled(props, { activeKey: "onSelect" });
	const bsPrefix = useBootstrapPrefix(initialBsPrefix, "list-group");
	let horizontalVariant;
	if (horizontal) horizontalVariant = horizontal === true ? "horizontal" : `horizontal-${horizontal}`;
	(0, import_warning$1.default)(!(horizontal && variant === "flush"), "`variant=\"flush\"` and `horizontal` should not be used together.");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Nav_default$1, {
		ref,
		...controlledProps,
		as,
		className: (0, import_classnames$28.default)(className, bsPrefix, variant && `${bsPrefix}-${variant}`, horizontalVariant && `${bsPrefix}-${horizontalVariant}`, numbered && `${bsPrefix}-numbered`)
	});
});
ListGroup.displayName = "ListGroup";
var ListGroup_default = Object.assign(ListGroup, { Item: ListGroupItem_default });

//#endregion
//#region node_modules/dom-helpers/esm/scrollbarSize.js
var size;
function scrollbarSize(recalc) {
	if (!size && size !== 0 || recalc) {
		if (canUseDOM_default) {
			var scrollDiv = document.createElement("div");
			scrollDiv.style.position = "absolute";
			scrollDiv.style.top = "-9999px";
			scrollDiv.style.width = "50px";
			scrollDiv.style.height = "50px";
			scrollDiv.style.overflow = "scroll";
			document.body.appendChild(scrollDiv);
			size = scrollDiv.offsetWidth - scrollDiv.clientWidth;
			document.body.removeChild(scrollDiv);
		}
	}
	return size;
}

//#endregion
//#region node_modules/@restart/hooks/esm/useCallbackRef.js
/**
* A convenience hook around `useState` designed to be paired with
* the component [callback ref](https://reactjs.org/docs/refs-and-the-dom.html#callback-refs) api.
* Callback refs are useful over `useRef()` when you need to respond to the ref being set
* instead of lazily accessing it in an effect.
*
* ```ts
* const [element, attachRef] = useCallbackRef<HTMLDivElement>()
*
* useEffect(() => {
*   if (!element) return
*
*   const calendar = new FullCalendar.Calendar(element)
*
*   return () => {
*     calendar.destroy()
*   }
* }, [element])
*
* return <div ref={attachRef} />
* ```
*
* @category refs
*/
function useCallbackRef$1() {
	return (0, import_react.useState)(null);
}

//#endregion
//#region node_modules/react-bootstrap/esm/ModalBody.js
var import_classnames$27 = /* @__PURE__ */ __toESM(require_classnames());
var ModalBody = /* @__PURE__ */ import_react.forwardRef(({ className, bsPrefix, as: Component = "div",...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "modal-body");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		className: (0, import_classnames$27.default)(className, bsPrefix),
		...props
	});
});
ModalBody.displayName = "ModalBody";
var ModalBody_default = ModalBody;

//#endregion
//#region node_modules/react-bootstrap/esm/ModalDialog.js
var import_classnames$26 = /* @__PURE__ */ __toESM(require_classnames());
var ModalDialog = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, className, contentClassName, centered, size: size$1, fullscreen, children, scrollable,...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "modal");
	const dialogClass = `${bsPrefix}-dialog`;
	const fullScreenClass = typeof fullscreen === "string" ? `${bsPrefix}-fullscreen-${fullscreen}` : `${bsPrefix}-fullscreen`;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		...props,
		ref,
		className: (0, import_classnames$26.default)(dialogClass, className, size$1 && `${bsPrefix}-${size$1}`, centered && `${dialogClass}-centered`, scrollable && `${dialogClass}-scrollable`, fullscreen && fullScreenClass),
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: (0, import_classnames$26.default)(`${bsPrefix}-content`, contentClassName),
			children
		})
	});
});
ModalDialog.displayName = "ModalDialog";
var ModalDialog_default = ModalDialog;

//#endregion
//#region node_modules/react-bootstrap/esm/ModalFooter.js
var import_classnames$25 = /* @__PURE__ */ __toESM(require_classnames());
var ModalFooter = /* @__PURE__ */ import_react.forwardRef(({ className, bsPrefix, as: Component = "div",...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "modal-footer");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		className: (0, import_classnames$25.default)(className, bsPrefix),
		...props
	});
});
ModalFooter.displayName = "ModalFooter";
var ModalFooter_default = ModalFooter;

//#endregion
//#region node_modules/react-bootstrap/esm/ModalHeader.js
var import_classnames$24 = /* @__PURE__ */ __toESM(require_classnames());
var ModalHeader = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, className, closeLabel = "Close", closeButton = false,...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "modal-header");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(AbstractModalHeader_default, {
		ref,
		...props,
		className: (0, import_classnames$24.default)(className, bsPrefix),
		closeLabel,
		closeButton
	});
});
ModalHeader.displayName = "ModalHeader";
var ModalHeader_default = ModalHeader;

//#endregion
//#region node_modules/react-bootstrap/esm/ModalTitle.js
var import_classnames$23 = /* @__PURE__ */ __toESM(require_classnames());
var DivStyledAsH4 = divWithClassName_default("h4");
var ModalTitle = /* @__PURE__ */ import_react.forwardRef(({ className, bsPrefix, as: Component = DivStyledAsH4,...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "modal-title");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		className: (0, import_classnames$23.default)(className, bsPrefix),
		...props
	});
});
ModalTitle.displayName = "ModalTitle";
var ModalTitle_default = ModalTitle;

//#endregion
//#region node_modules/react-bootstrap/esm/Modal.js
var import_classnames$22 = /* @__PURE__ */ __toESM(require_classnames());
function DialogTransition(props) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Fade_default, {
		...props,
		timeout: null
	});
}
function BackdropTransition(props) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Fade_default, {
		...props,
		timeout: null
	});
}
var Modal = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, className, style, dialogClassName, contentClassName, children, dialogAs: Dialog = ModalDialog_default, "data-bs-theme": dataBsTheme, "aria-labelledby": ariaLabelledby, "aria-describedby": ariaDescribedby, "aria-label": ariaLabel, show = false, animation = true, backdrop = true, keyboard = true, onEscapeKeyDown, onShow, onHide, container, autoFocus = true, enforceFocus = true, restoreFocus = true, restoreFocusOptions, onEntered, onExit, onExiting, onEnter, onEntering, onExited, backdropClassName, manager: propsManager,...props }, ref) => {
	const [modalStyle, setStyle] = (0, import_react.useState)({});
	const [animateStaticModal, setAnimateStaticModal] = (0, import_react.useState)(false);
	const waitingForMouseUpRef = (0, import_react.useRef)(false);
	const ignoreBackdropClickRef = (0, import_react.useRef)(false);
	const removeStaticModalAnimationRef = (0, import_react.useRef)(null);
	const [modal, setModalRef] = useCallbackRef$1();
	const mergedRef = useMergedRefs_default(ref, setModalRef);
	const handleHide = useEventCallback(onHide);
	const isRTL = useIsRTL();
	bsPrefix = useBootstrapPrefix(bsPrefix, "modal");
	const modalContext = (0, import_react.useMemo)(() => ({ onHide: handleHide }), [handleHide]);
	function getModalManager() {
		if (propsManager) return propsManager;
		return getSharedManager({ isRTL });
	}
	function updateDialogStyle(node) {
		if (!canUseDOM_default) return;
		const containerIsOverflowing = getModalManager().getScrollbarWidth() > 0;
		const modalIsOverflowing = node.scrollHeight > ownerDocument(node).documentElement.clientHeight;
		setStyle({
			paddingRight: containerIsOverflowing && !modalIsOverflowing ? scrollbarSize() : void 0,
			paddingLeft: !containerIsOverflowing && modalIsOverflowing ? scrollbarSize() : void 0
		});
	}
	const handleWindowResize = useEventCallback(() => {
		if (modal) updateDialogStyle(modal.dialog);
	});
	useWillUnmount(() => {
		removeEventListener_default(window, "resize", handleWindowResize);
		removeStaticModalAnimationRef.current == null || removeStaticModalAnimationRef.current();
	});
	const handleDialogMouseDown = () => {
		waitingForMouseUpRef.current = true;
	};
	const handleMouseUp = (e) => {
		if (waitingForMouseUpRef.current && modal && e.target === modal.dialog) ignoreBackdropClickRef.current = true;
		waitingForMouseUpRef.current = false;
	};
	const handleStaticModalAnimation = () => {
		setAnimateStaticModal(true);
		removeStaticModalAnimationRef.current = transitionEnd(modal.dialog, () => {
			setAnimateStaticModal(false);
		});
	};
	const handleStaticBackdropClick = (e) => {
		if (e.target !== e.currentTarget) return;
		handleStaticModalAnimation();
	};
	const handleClick = (e) => {
		if (backdrop === "static") {
			handleStaticBackdropClick(e);
			return;
		}
		if (ignoreBackdropClickRef.current || e.target !== e.currentTarget) {
			ignoreBackdropClickRef.current = false;
			return;
		}
		onHide?.();
	};
	const handleEscapeKeyDown = (e) => {
		if (keyboard) onEscapeKeyDown?.(e);
		else {
			e.preventDefault();
			if (backdrop === "static") handleStaticModalAnimation();
		}
	};
	const handleEnter = (node, isAppearing) => {
		if (node) updateDialogStyle(node);
		onEnter?.(node, isAppearing);
	};
	const handleExit = (node) => {
		removeStaticModalAnimationRef.current == null || removeStaticModalAnimationRef.current();
		onExit?.(node);
	};
	const handleEntering = (node, isAppearing) => {
		onEntering?.(node, isAppearing);
		addEventListener_default(window, "resize", handleWindowResize);
	};
	const handleExited = (node) => {
		if (node) node.style.display = "";
		onExited?.(node);
		removeEventListener_default(window, "resize", handleWindowResize);
	};
	const renderBackdrop = (0, import_react.useCallback)((backdropProps) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		...backdropProps,
		className: (0, import_classnames$22.default)(`${bsPrefix}-backdrop`, backdropClassName, !animation && "show")
	}), [
		animation,
		backdropClassName,
		bsPrefix
	]);
	const baseModalStyle = {
		...style,
		...modalStyle
	};
	baseModalStyle.display = "block";
	const renderDialog = (dialogProps) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		role: "dialog",
		...dialogProps,
		style: baseModalStyle,
		className: (0, import_classnames$22.default)(className, bsPrefix, animateStaticModal && `${bsPrefix}-static`, !animation && "show"),
		onClick: backdrop ? handleClick : void 0,
		onMouseUp: handleMouseUp,
		"data-bs-theme": dataBsTheme,
		"aria-label": ariaLabel,
		"aria-labelledby": ariaLabelledby,
		"aria-describedby": ariaDescribedby,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Dialog, {
			...props,
			onMouseDown: handleDialogMouseDown,
			className: dialogClassName,
			contentClassName,
			children
		})
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ModalContext_default.Provider, {
		value: modalContext,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Modal_default$1, {
			show,
			ref: mergedRef,
			backdrop,
			container,
			keyboard: true,
			autoFocus,
			enforceFocus,
			restoreFocus,
			restoreFocusOptions,
			onEscapeKeyDown: handleEscapeKeyDown,
			onShow,
			onHide,
			onEnter: handleEnter,
			onEntering: handleEntering,
			onEntered,
			onExit: handleExit,
			onExiting,
			onExited: handleExited,
			manager: getModalManager(),
			transition: animation ? DialogTransition : void 0,
			backdropTransition: animation ? BackdropTransition : void 0,
			renderBackdrop,
			renderDialog
		})
	});
});
Modal.displayName = "Modal";
var Modal_default = Object.assign(Modal, {
	Body: ModalBody_default,
	Header: ModalHeader_default,
	Title: ModalTitle_default,
	Footer: ModalFooter_default,
	Dialog: ModalDialog_default,
	TRANSITION_DURATION: 300,
	BACKDROP_TRANSITION_DURATION: 150
});

//#endregion
//#region node_modules/react-bootstrap/esm/NavDropdown.js
var import_classnames$21 = /* @__PURE__ */ __toESM(require_classnames());
var NavDropdown = /* @__PURE__ */ import_react.forwardRef(({ id, title, children, bsPrefix, className, rootCloseEvent, menuRole, disabled, active, renderMenuOnMount, menuVariant,...props }, ref) => {
	const navItemPrefix = useBootstrapPrefix(void 0, "nav-item");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Dropdown_default, {
		ref,
		...props,
		className: (0, import_classnames$21.default)(className, navItemPrefix),
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Dropdown_default.Toggle, {
			id,
			eventKey: null,
			active,
			disabled,
			childBsPrefix: bsPrefix,
			as: NavLink_default,
			children: title
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Dropdown_default.Menu, {
			role: menuRole,
			renderOnMount: renderMenuOnMount,
			rootCloseEvent,
			variant: menuVariant,
			children
		})]
	});
});
NavDropdown.displayName = "NavDropdown";
var NavDropdown_default = Object.assign(NavDropdown, {
	Item: Dropdown_default.Item,
	ItemText: Dropdown_default.ItemText,
	Divider: Dropdown_default.Divider,
	Header: Dropdown_default.Header
});

//#endregion
//#region node_modules/@restart/ui/esm/useRootClose.js
var import_react_dom = /* @__PURE__ */ __toESM(require_react_dom());
var noop$1 = () => {};
/**
* The `useRootClose` hook registers your callback on the document
* when rendered. Powers the `<Overlay/>` component. This is used achieve modal
* style behavior where your callback is triggered when the user tries to
* interact with the rest of the document or hits the `esc` key.
*
* @param {Ref<HTMLElement>| HTMLElement} ref  The element boundary
* @param {function} onRootClose
* @param {object=}  options
* @param {boolean=} options.disabled
* @param {string=}  options.clickTrigger The DOM event name (click, mousedown, etc) to attach listeners on
*/
function useRootClose(ref, onRootClose, { disabled, clickTrigger } = {}) {
	const onClose = onRootClose || noop$1;
	useClickOutside_default(ref, onClose, {
		disabled,
		clickTrigger
	});
	const handleKeyUp = useEventCallback$1((e) => {
		if (isEscKey(e)) onClose(e);
	});
	(0, import_react.useEffect)(() => {
		if (disabled || ref == null) return void 0;
		const doc = ownerDocument(getRefTarget(ref));
		let currentEvent = (doc.defaultView || window).event;
		const removeKeyupListener = listen_default(doc, "keyup", (e) => {
			if (e === currentEvent) {
				currentEvent = void 0;
				return;
			}
			handleKeyUp(e);
		});
		return () => {
			removeKeyupListener();
		};
	}, [
		ref,
		disabled,
		handleKeyUp
	]);
}
var useRootClose_default = useRootClose;

//#endregion
//#region node_modules/@restart/ui/esm/Overlay.js
/**
* Built on top of `Popper.js`, the overlay component is
* great for custom tooltip overlays.
*/
var Overlay$1 = /* @__PURE__ */ import_react.forwardRef((props, outerRef) => {
	const { flip: flip$1, offset: offset$1, placement, containerPadding, popperConfig = {}, transition: Transition, runTransition } = props;
	const [rootElement, attachRef] = useCallbackRef();
	const [arrowElement, attachArrowRef] = useCallbackRef();
	const mergedRef = useMergedRefs_default$1(attachRef, outerRef);
	const container = useWaitForDOMRef(props.container);
	const target = useWaitForDOMRef(props.target);
	const [exited, setExited] = (0, import_react.useState)(!props.show);
	const popper$1 = usePopper_default(target, rootElement, mergeOptionsWithPopperConfig({
		placement,
		enableEvents: !!props.show,
		containerPadding: containerPadding || 5,
		flip: flip$1,
		offset: offset$1,
		arrowElement,
		popperConfig
	}));
	if (props.show && exited) setExited(false);
	const handleHidden = (...args) => {
		setExited(true);
		if (props.onExited) props.onExited(...args);
	};
	const mountOverlay = props.show || !exited;
	useRootClose_default(rootElement, props.onHide, {
		disabled: !props.rootClose || props.rootCloseDisabled,
		clickTrigger: props.rootCloseEvent
	});
	if (!mountOverlay) return null;
	const { onExit, onExiting, onEnter, onEntering, onEntered } = props;
	let child = props.children(Object.assign({}, popper$1.attributes.popper, {
		style: popper$1.styles.popper,
		ref: mergedRef
	}), {
		popper: popper$1,
		placement,
		show: !!props.show,
		arrowProps: Object.assign({}, popper$1.attributes.arrow, {
			style: popper$1.styles.arrow,
			ref: attachArrowRef
		})
	});
	child = renderTransition(Transition, runTransition, {
		in: !!props.show,
		appear: true,
		mountOnEnter: true,
		unmountOnExit: true,
		children: child,
		onExit,
		onExiting,
		onExited: handleHidden,
		onEnter,
		onEntering,
		onEntered
	});
	return container ? /* @__PURE__ */ import_react_dom.createPortal(child, container) : null;
});
Overlay$1.displayName = "Overlay";
var Overlay_default$1 = Overlay$1;

//#endregion
//#region node_modules/react-bootstrap/esm/PopoverHeader.js
var import_classnames$20 = /* @__PURE__ */ __toESM(require_classnames());
var PopoverHeader = /* @__PURE__ */ import_react.forwardRef(({ className, bsPrefix, as: Component = "div",...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "popover-header");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		className: (0, import_classnames$20.default)(className, bsPrefix),
		...props
	});
});
PopoverHeader.displayName = "PopoverHeader";
var PopoverHeader_default = PopoverHeader;

//#endregion
//#region node_modules/react-bootstrap/esm/PopoverBody.js
var import_classnames$19 = /* @__PURE__ */ __toESM(require_classnames());
var PopoverBody = /* @__PURE__ */ import_react.forwardRef(({ className, bsPrefix, as: Component = "div",...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "popover-body");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		className: (0, import_classnames$19.default)(className, bsPrefix),
		...props
	});
});
PopoverBody.displayName = "PopoverBody";
var PopoverBody_default = PopoverBody;

//#endregion
//#region node_modules/react-bootstrap/esm/helpers.js
function getOverlayDirection(placement, isRTL) {
	let bsDirection = placement;
	if (placement === "left") bsDirection = isRTL ? "end" : "start";
	else if (placement === "right") bsDirection = isRTL ? "start" : "end";
	return bsDirection;
}

//#endregion
//#region node_modules/react-bootstrap/esm/getInitialPopperStyles.js
function getInitialPopperStyles(position = "absolute") {
	return {
		position,
		top: "0",
		left: "0",
		opacity: "0",
		pointerEvents: "none"
	};
}

//#endregion
//#region node_modules/react-bootstrap/esm/Popover.js
var import_classnames$18 = /* @__PURE__ */ __toESM(require_classnames());
var Popover = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, placement = "right", className, style, children, body, arrowProps, hasDoneInitialMeasure, popper: popper$1, show,...props }, ref) => {
	const decoratedBsPrefix = useBootstrapPrefix(bsPrefix, "popover");
	const isRTL = useIsRTL();
	const [primaryPlacement] = (placement == null ? void 0 : placement.split("-")) || [];
	const bsDirection = getOverlayDirection(primaryPlacement, isRTL);
	let computedStyle = style;
	if (show && !hasDoneInitialMeasure) computedStyle = {
		...style,
		...getInitialPopperStyles(popper$1 == null ? void 0 : popper$1.strategy)
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		ref,
		role: "tooltip",
		style: computedStyle,
		"x-placement": primaryPlacement,
		className: (0, import_classnames$18.default)(className, decoratedBsPrefix, primaryPlacement && `bs-popover-${bsDirection}`),
		...props,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: "popover-arrow",
			...arrowProps
		}), body ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PopoverBody_default, { children }) : children]
	});
});
Popover.displayName = "Popover";
var Popover_default = Object.assign(Popover, {
	Header: PopoverHeader_default,
	Body: PopoverBody_default,
	POPPER_OFFSET: [0, 8]
});

//#endregion
//#region node_modules/react-bootstrap/esm/Tooltip.js
var import_classnames$17 = /* @__PURE__ */ __toESM(require_classnames());
var Tooltip = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, placement = "right", className, style, children, arrowProps, hasDoneInitialMeasure, popper: popper$1, show,...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "tooltip");
	const isRTL = useIsRTL();
	const [primaryPlacement] = (placement == null ? void 0 : placement.split("-")) || [];
	const bsDirection = getOverlayDirection(primaryPlacement, isRTL);
	let computedStyle = style;
	if (show && !hasDoneInitialMeasure) computedStyle = {
		...style,
		...getInitialPopperStyles(popper$1 == null ? void 0 : popper$1.strategy)
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		ref,
		style: computedStyle,
		role: "tooltip",
		"x-placement": primaryPlacement,
		className: (0, import_classnames$17.default)(className, bsPrefix, `bs-tooltip-${bsDirection}`),
		...props,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: "tooltip-arrow",
			...arrowProps
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: `${bsPrefix}-inner`,
			children
		})]
	});
});
Tooltip.displayName = "Tooltip";
var Tooltip_default = Object.assign(Tooltip, { TOOLTIP_OFFSET: [0, 6] });

//#endregion
//#region node_modules/react-bootstrap/esm/useOverlayOffset.js
function useOverlayOffset(customOffset) {
	const overlayRef = (0, import_react.useRef)(null);
	const popoverClass = useBootstrapPrefix(void 0, "popover");
	const tooltipClass = useBootstrapPrefix(void 0, "tooltip");
	const offset$1 = (0, import_react.useMemo)(() => ({
		name: "offset",
		options: { offset: () => {
			if (customOffset) return customOffset;
			if (overlayRef.current) {
				if (hasClass(overlayRef.current, popoverClass)) return Popover_default.POPPER_OFFSET;
				if (hasClass(overlayRef.current, tooltipClass)) return Tooltip_default.TOOLTIP_OFFSET;
			}
			return [0, 0];
		} }
	}), [
		customOffset,
		popoverClass,
		tooltipClass
	]);
	return [overlayRef, [offset$1]];
}

//#endregion
//#region node_modules/react-bootstrap/esm/Overlay.js
var import_classnames$16 = /* @__PURE__ */ __toESM(require_classnames());
function wrapRefs(props, arrowProps) {
	const { ref } = props;
	const { ref: aRef } = arrowProps;
	props.ref = ref.__wrapped || (ref.__wrapped = (r) => ref(safeFindDOMNode(r)));
	arrowProps.ref = aRef.__wrapped || (aRef.__wrapped = (r) => aRef(safeFindDOMNode(r)));
}
var Overlay = /* @__PURE__ */ import_react.forwardRef(({ children: overlay, transition = Fade_default, popperConfig = {}, rootClose = false, placement = "top", show: outerShow = false,...outerProps }, outerRef) => {
	const popperRef = (0, import_react.useRef)({});
	const [firstRenderedState, setFirstRenderedState] = (0, import_react.useState)(null);
	const [ref, modifiers] = useOverlayOffset(outerProps.offset);
	const mergedRef = useMergedRefs_default(outerRef, ref);
	const actualTransition = transition === true ? Fade_default : transition || void 0;
	const handleFirstUpdate = useEventCallback((state) => {
		setFirstRenderedState(state);
		popperConfig == null || popperConfig.onFirstUpdate == null || popperConfig.onFirstUpdate(state);
	});
	useIsomorphicEffect_default(() => {
		if (firstRenderedState && outerProps.target) popperRef.current.scheduleUpdate == null || popperRef.current.scheduleUpdate();
	}, [firstRenderedState, outerProps.target]);
	(0, import_react.useEffect)(() => {
		if (!outerShow) setFirstRenderedState(null);
	}, [outerShow]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Overlay_default$1, {
		...outerProps,
		ref: mergedRef,
		popperConfig: {
			...popperConfig,
			modifiers: modifiers.concat(popperConfig.modifiers || []),
			onFirstUpdate: handleFirstUpdate
		},
		transition: actualTransition,
		rootClose,
		placement,
		show: outerShow,
		children: (overlayProps, { arrowProps, popper: popperObj, show }) => {
			var _popperObj$state;
			wrapRefs(overlayProps, arrowProps);
			const updatedPlacement = popperObj == null ? void 0 : popperObj.placement;
			const popper$1 = Object.assign(popperRef.current, {
				state: popperObj == null ? void 0 : popperObj.state,
				scheduleUpdate: popperObj == null ? void 0 : popperObj.update,
				placement: updatedPlacement,
				outOfBoundaries: (popperObj == null || (_popperObj$state = popperObj.state) == null || (_popperObj$state = _popperObj$state.modifiersData.hide) == null ? void 0 : _popperObj$state.isReferenceHidden) || false,
				strategy: popperConfig.strategy
			});
			const hasDoneInitialMeasure = !!firstRenderedState;
			if (typeof overlay === "function") return overlay({
				...overlayProps,
				placement: updatedPlacement,
				show,
				...!transition && show && { className: "show" },
				popper: popper$1,
				arrowProps,
				hasDoneInitialMeasure
			});
			return /* @__PURE__ */ import_react.cloneElement(overlay, {
				...overlayProps,
				placement: updatedPlacement,
				arrowProps,
				popper: popper$1,
				hasDoneInitialMeasure,
				className: (0, import_classnames$16.default)(overlay.props.className, !transition && show && "show"),
				style: {
					...overlay.props.style,
					...overlayProps.style
				}
			});
		}
	});
});
Overlay.displayName = "Overlay";
var Overlay_default = Overlay;

//#endregion
//#region node_modules/react-bootstrap/esm/OverlayTrigger.js
var import_prop_types$3 = /* @__PURE__ */ __toESM(require_prop_types());
var import_warning = /* @__PURE__ */ __toESM(require_warning());
function normalizeDelay(delay) {
	return delay && typeof delay === "object" ? delay : {
		show: delay,
		hide: delay
	};
}
function handleMouseOverOut(handler, args, relatedNative) {
	const [e] = args;
	const target = e.currentTarget;
	const related = e.relatedTarget || e.nativeEvent[relatedNative];
	if ((!related || related !== target) && !contains(target, related)) handler(...args);
}
import_prop_types$3.default.oneOf([
	"click",
	"hover",
	"focus"
]);
var OverlayTrigger = ({ trigger = ["hover", "focus"], overlay, children, popperConfig = {}, show: propsShow, defaultShow = false, onToggle, delay: propsDelay, placement, flip: flip$1 = placement && placement.indexOf("auto") !== -1,...props }) => {
	const triggerNodeRef = (0, import_react.useRef)(null);
	const mergedRef = useMergedRefs_default(triggerNodeRef, getChildRef(children));
	const timeout = useTimeout();
	const hoverStateRef = (0, import_react.useRef)("");
	const [show, setShow] = useUncontrolledProp$1(propsShow, defaultShow, onToggle);
	const delay = normalizeDelay(propsDelay);
	const { onFocus, onBlur, onClick } = typeof children !== "function" ? import_react.Children.only(children).props : {};
	const attachRef = (r) => {
		mergedRef(safeFindDOMNode(r));
	};
	const handleShow = (0, import_react.useCallback)(() => {
		timeout.clear();
		hoverStateRef.current = "show";
		if (!delay.show) {
			setShow(true);
			return;
		}
		timeout.set(() => {
			if (hoverStateRef.current === "show") setShow(true);
		}, delay.show);
	}, [
		delay.show,
		setShow,
		timeout
	]);
	const handleHide = (0, import_react.useCallback)(() => {
		timeout.clear();
		hoverStateRef.current = "hide";
		if (!delay.hide) {
			setShow(false);
			return;
		}
		timeout.set(() => {
			if (hoverStateRef.current === "hide") setShow(false);
		}, delay.hide);
	}, [
		delay.hide,
		setShow,
		timeout
	]);
	const handleFocus = (0, import_react.useCallback)((...args) => {
		handleShow();
		onFocus?.(...args);
	}, [handleShow, onFocus]);
	const handleBlur = (0, import_react.useCallback)((...args) => {
		handleHide();
		onBlur?.(...args);
	}, [handleHide, onBlur]);
	const handleClick = (0, import_react.useCallback)((...args) => {
		setShow(!show);
		onClick?.(...args);
	}, [
		onClick,
		setShow,
		show
	]);
	const handleMouseOver = (0, import_react.useCallback)((...args) => {
		handleMouseOverOut(handleShow, args, "fromElement");
	}, [handleShow]);
	const handleMouseOut = (0, import_react.useCallback)((...args) => {
		handleMouseOverOut(handleHide, args, "toElement");
	}, [handleHide]);
	const triggers = trigger == null ? [] : [].concat(trigger);
	const triggerProps = { ref: attachRef };
	if (triggers.indexOf("click") !== -1) triggerProps.onClick = handleClick;
	if (triggers.indexOf("focus") !== -1) {
		triggerProps.onFocus = handleFocus;
		triggerProps.onBlur = handleBlur;
	}
	if (triggers.indexOf("hover") !== -1) {
		(0, import_warning.default)(triggers.length > 1, "[react-bootstrap] Specifying only the `\"hover\"` trigger limits the visibility of the overlay to just mouse users. Consider also including the `\"focus\"` trigger so that touch and keyboard only users can see the overlay as well.");
		triggerProps.onMouseOver = handleMouseOver;
		triggerProps.onMouseOut = handleMouseOut;
	}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [typeof children === "function" ? children(triggerProps) : /* @__PURE__ */ (0, import_react.cloneElement)(children, triggerProps), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Overlay_default, {
		...props,
		show,
		onHide: handleHide,
		flip: flip$1,
		placement,
		popperConfig,
		target: triggerNodeRef.current,
		children: overlay
	})] });
};
var OverlayTrigger_default = OverlayTrigger;

//#endregion
//#region node_modules/react-bootstrap/esm/PageItem.js
var import_classnames$15 = /* @__PURE__ */ __toESM(require_classnames());
var PageItem = /* @__PURE__ */ import_react.forwardRef(({ active = false, disabled = false, className, style, activeLabel = "(current)", children, linkStyle, linkClassName, as = Anchor_default$1,...props }, ref) => {
	const Component = active || disabled ? "span" : as;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("li", {
		ref,
		style,
		className: (0, import_classnames$15.default)(className, "page-item", {
			active,
			disabled
		}),
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Component, {
			className: (0, import_classnames$15.default)("page-link", linkClassName),
			style: linkStyle,
			...props,
			children: [children, active && activeLabel && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
				className: "visually-hidden",
				children: activeLabel
			})]
		})
	});
});
PageItem.displayName = "PageItem";
var PageItem_default = PageItem;
function createButton(name, defaultValue, label = name) {
	const Button$1 = /* @__PURE__ */ import_react.forwardRef(({ children,...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(PageItem, {
		...props,
		ref,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
			"aria-hidden": "true",
			children: children || defaultValue
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
			className: "visually-hidden",
			children: label
		})]
	}));
	Button$1.displayName = name;
	return Button$1;
}
const First = createButton("First", "");
const Prev = createButton("Prev", "", "Previous");
const Ellipsis = createButton("Ellipsis", "", "More");
const Next = createButton("Next", "");
const Last = createButton("Last", "");

//#endregion
//#region node_modules/react-bootstrap/esm/Pagination.js
var import_classnames$14 = /* @__PURE__ */ __toESM(require_classnames());
var Pagination = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, className, size: size$1,...props }, ref) => {
	const decoratedBsPrefix = useBootstrapPrefix(bsPrefix, "pagination");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("ul", {
		ref,
		...props,
		className: (0, import_classnames$14.default)(className, decoratedBsPrefix, size$1 && `${decoratedBsPrefix}-${size$1}`)
	});
});
Pagination.displayName = "Pagination";
var Pagination_default = Object.assign(Pagination, {
	First,
	Prev,
	Ellipsis,
	Item: PageItem_default,
	Next,
	Last
});

//#endregion
//#region node_modules/react-bootstrap/esm/usePlaceholder.js
var import_classnames$13 = /* @__PURE__ */ __toESM(require_classnames());
function usePlaceholder({ animation, bg, bsPrefix, size: size$1,...props }) {
	bsPrefix = useBootstrapPrefix(bsPrefix, "placeholder");
	const [{ className,...colProps }] = useCol(props);
	return {
		...colProps,
		className: (0, import_classnames$13.default)(className, animation ? `${bsPrefix}-${animation}` : bsPrefix, size$1 && `${bsPrefix}-${size$1}`, bg && `bg-${bg}`)
	};
}

//#endregion
//#region node_modules/react-bootstrap/esm/PlaceholderButton.js
var PlaceholderButton = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const placeholderProps = usePlaceholder(props);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Button_default, {
		...placeholderProps,
		ref,
		disabled: true,
		tabIndex: -1
	});
});
PlaceholderButton.displayName = "PlaceholderButton";
var PlaceholderButton_default = PlaceholderButton;

//#endregion
//#region node_modules/react-bootstrap/esm/Placeholder.js
var Placeholder = /* @__PURE__ */ import_react.forwardRef(({ as: Component = "span",...props }, ref) => {
	const placeholderProps = usePlaceholder(props);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		...placeholderProps,
		ref
	});
});
Placeholder.displayName = "Placeholder";
var Placeholder_default = Object.assign(Placeholder, { Button: PlaceholderButton_default });

//#endregion
//#region node_modules/react-bootstrap/esm/ProgressBar.js
var import_classnames$12 = /* @__PURE__ */ __toESM(require_classnames());
var ROUND_PRECISION = 1e3;
function getPercentage(now, min$1, max$1) {
	const percentage = (now - min$1) / (max$1 - min$1) * 100;
	return Math.round(percentage * ROUND_PRECISION) / ROUND_PRECISION;
}
function renderProgressBar({ min: min$1, now, max: max$1, label, visuallyHidden, striped, animated, className, style, variant, bsPrefix,...props }, ref) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		ref,
		...props,
		role: "progressbar",
		className: (0, import_classnames$12.default)(className, `${bsPrefix}-bar`, {
			[`bg-${variant}`]: variant,
			[`${bsPrefix}-bar-animated`]: animated,
			[`${bsPrefix}-bar-striped`]: animated || striped
		}),
		style: {
			width: `${getPercentage(now, min$1, max$1)}%`,
			...style
		},
		"aria-valuenow": now,
		"aria-valuemin": min$1,
		"aria-valuemax": max$1,
		children: visuallyHidden ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
			className: "visually-hidden",
			children: label
		}) : label
	});
}
var ProgressBar = /* @__PURE__ */ import_react.forwardRef(({ isChild = false,...rest }, ref) => {
	const props = {
		min: 0,
		max: 100,
		animated: false,
		visuallyHidden: false,
		striped: false,
		...rest
	};
	props.bsPrefix = useBootstrapPrefix(props.bsPrefix, "progress");
	if (isChild) return renderProgressBar(props, ref);
	const { min: min$1, now, max: max$1, label, visuallyHidden, striped, animated, bsPrefix, variant, className, children,...wrapperProps } = props;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		ref,
		...wrapperProps,
		className: (0, import_classnames$12.default)(className, bsPrefix),
		children: children ? map(children, (child) => /* @__PURE__ */ (0, import_react.cloneElement)(child, { isChild: true })) : renderProgressBar({
			min: min$1,
			now,
			max: max$1,
			label,
			visuallyHidden,
			striped,
			animated,
			bsPrefix,
			variant
		}, ref)
	});
});
ProgressBar.displayName = "ProgressBar";
var ProgressBar_default = ProgressBar;

//#endregion
//#region node_modules/react-bootstrap/esm/Ratio.js
var import_classnames$11 = /* @__PURE__ */ __toESM(require_classnames());
function toPercent(num) {
	if (num <= 0) return "100%";
	if (num < 1) return `${num * 100}%`;
	return `${num}%`;
}
var Ratio = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, className, children, aspectRatio = "1x1", style,...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "ratio");
	const isCustomRatio = typeof aspectRatio === "number";
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		ref,
		...props,
		style: {
			...style,
			...isCustomRatio && { "--bs-aspect-ratio": toPercent(aspectRatio) }
		},
		className: (0, import_classnames$11.default)(bsPrefix, className, !isCustomRatio && `${bsPrefix}-${aspectRatio}`),
		children: import_react.Children.only(children)
	});
});
Ratio.displayName = "Ratio";
var Ratio_default = Ratio;

//#endregion
//#region node_modules/react-bootstrap/esm/Row.js
var import_classnames$10 = /* @__PURE__ */ __toESM(require_classnames());
var Row = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, className, as: Component = "div",...props }, ref) => {
	const decoratedBsPrefix = useBootstrapPrefix(bsPrefix, "row");
	const breakpoints = useBootstrapBreakpoints();
	const minBreakpoint = useBootstrapMinBreakpoint();
	const sizePrefix = `${decoratedBsPrefix}-cols`;
	const classes = [];
	breakpoints.forEach((brkPoint) => {
		const propValue = props[brkPoint];
		delete props[brkPoint];
		let cols;
		if (propValue != null && typeof propValue === "object") ({cols} = propValue);
		else cols = propValue;
		const infix = brkPoint !== minBreakpoint ? `-${brkPoint}` : "";
		if (cols != null) classes.push(`${sizePrefix}${infix}-${cols}`);
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		...props,
		className: (0, import_classnames$10.default)(className, decoratedBsPrefix, ...classes)
	});
});
Row.displayName = "Row";
var Row_default = Row;

//#endregion
//#region node_modules/react-bootstrap/esm/Spinner.js
var import_classnames$9 = /* @__PURE__ */ __toESM(require_classnames());
var Spinner = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, variant, animation = "border", size: size$1, as: Component = "div", className,...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "spinner");
	const bsSpinnerPrefix = `${bsPrefix}-${animation}`;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		...props,
		className: (0, import_classnames$9.default)(className, bsSpinnerPrefix, size$1 && `${bsSpinnerPrefix}-${size$1}`, variant && `text-${variant}`)
	});
});
Spinner.displayName = "Spinner";
var Spinner_default = Spinner;

//#endregion
//#region node_modules/react-bootstrap/esm/SplitButton.js
var import_prop_types$2 = /* @__PURE__ */ __toESM(require_prop_types());
var propTypes$1 = {
	id: import_prop_types$2.default.string,
	toggleLabel: import_prop_types$2.default.string,
	href: import_prop_types$2.default.string,
	target: import_prop_types$2.default.string,
	onClick: import_prop_types$2.default.func,
	title: import_prop_types$2.default.node.isRequired,
	type: import_prop_types$2.default.string,
	disabled: import_prop_types$2.default.bool,
	align: alignPropType,
	menuRole: import_prop_types$2.default.string,
	renderMenuOnMount: import_prop_types$2.default.bool,
	rootCloseEvent: import_prop_types$2.default.string,
	flip: import_prop_types$2.default.bool,
	bsPrefix: import_prop_types$2.default.string,
	variant: import_prop_types$2.default.string,
	size: import_prop_types$2.default.string
};
/**
* A convenience component for simple or general use split button dropdowns. Renders a
* `ButtonGroup` containing a `Button` and a `Button` toggle for the `Dropdown`. All `children`
* are passed directly to the default `Dropdown.Menu`. This component accepts all of [`Dropdown`'s
* props](#dropdown-props).
*
* _All unknown props are passed through to the `Dropdown` component._
* The Button `variant`, `size` and `bsPrefix` props are passed to the button and toggle,
* and menu-related props are passed to the `Dropdown.Menu`
*/
var SplitButton = /* @__PURE__ */ import_react.forwardRef(({ id, bsPrefix, size: size$1, variant, title, type = "button", toggleLabel = "Toggle dropdown", children, onClick, href, target, menuRole, renderMenuOnMount, rootCloseEvent, flip: flip$1,...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Dropdown_default, {
	ref,
	...props,
	as: ButtonGroup_default,
	children: [
		/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Button_default, {
			size: size$1,
			variant,
			disabled: props.disabled,
			bsPrefix,
			href,
			target,
			onClick,
			type,
			children: title
		}),
		/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Dropdown_default.Toggle, {
			split: true,
			id,
			size: size$1,
			variant,
			disabled: props.disabled,
			childBsPrefix: bsPrefix,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
				className: "visually-hidden",
				children: toggleLabel
			})
		}),
		/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Dropdown_default.Menu, {
			role: menuRole,
			renderOnMount: renderMenuOnMount,
			rootCloseEvent,
			flip: flip$1,
			children
		})
	]
}));
SplitButton.propTypes = propTypes$1;
SplitButton.displayName = "SplitButton";
var SplitButton_default = SplitButton;

//#endregion
//#region node_modules/react-bootstrap/esm/SSRProvider.js
var SSRProvider_default = $b5e257d569688ac6$export$9f8ac96af4b1b2ae;

//#endregion
//#region node_modules/react-bootstrap/esm/createUtilityClasses.js
var import_prop_types$1 = /* @__PURE__ */ __toESM(require_prop_types());
function createUtilityClassName(utilityValues, breakpoints = DEFAULT_BREAKPOINTS, minBreakpoint = DEFAULT_MIN_BREAKPOINT) {
	const classes = [];
	Object.entries(utilityValues).forEach(([utilName, utilValue]) => {
		if (utilValue != null) if (typeof utilValue === "object") breakpoints.forEach((brkPoint) => {
			const bpValue = utilValue[brkPoint];
			if (bpValue != null) {
				const infix = brkPoint !== minBreakpoint ? `-${brkPoint}` : "";
				classes.push(`${utilName}${infix}-${bpValue}`);
			}
		});
		else classes.push(`${utilName}-${utilValue}`);
	});
	return classes;
}

//#endregion
//#region node_modules/react-bootstrap/esm/Stack.js
var import_classnames$8 = /* @__PURE__ */ __toESM(require_classnames());
var Stack = /* @__PURE__ */ import_react.forwardRef(({ as: Component = "div", bsPrefix, className, direction, gap,...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, direction === "horizontal" ? "hstack" : "vstack");
	const breakpoints = useBootstrapBreakpoints();
	const minBreakpoint = useBootstrapMinBreakpoint();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		...props,
		ref,
		className: (0, import_classnames$8.default)(className, bsPrefix, ...createUtilityClassName({ gap }, breakpoints, minBreakpoint))
	});
});
Stack.displayName = "Stack";
var Stack_default = Stack;

//#endregion
//#region node_modules/@restart/ui/esm/TabPanel.js
var _excluded = [
	"active",
	"eventKey",
	"mountOnEnter",
	"transition",
	"unmountOnExit",
	"role",
	"onEnter",
	"onEntering",
	"onEntered",
	"onExit",
	"onExiting",
	"onExited"
], _excluded2 = [
	"activeKey",
	"getControlledId",
	"getControllerId"
], _excluded3 = ["as"];
function _objectWithoutPropertiesLoose(r, e) {
	if (null == r) return {};
	var t = {};
	for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
		if (e.indexOf(n) >= 0) continue;
		t[n] = r[n];
	}
	return t;
}
function useTabPanel(_ref) {
	let { active, eventKey, mountOnEnter, transition, unmountOnExit, role = "tabpanel", onEnter, onEntering, onEntered, onExit, onExiting, onExited } = _ref, props = _objectWithoutPropertiesLoose(_ref, _excluded);
	const context$3 = (0, import_react.useContext)(TabContext_default);
	if (!context$3) return [Object.assign({}, props, { role }), {
		eventKey,
		isActive: active,
		mountOnEnter,
		transition,
		unmountOnExit,
		onEnter,
		onEntering,
		onEntered,
		onExit,
		onExiting,
		onExited
	}];
	const { activeKey, getControlledId, getControllerId } = context$3, rest = _objectWithoutPropertiesLoose(context$3, _excluded2);
	const key = makeEventKey(eventKey);
	return [Object.assign({}, props, {
		role,
		id: getControlledId(eventKey),
		"aria-labelledby": getControllerId(eventKey)
	}), {
		eventKey,
		isActive: active == null && key != null ? makeEventKey(activeKey) === key : active,
		transition: transition || rest.transition,
		mountOnEnter: mountOnEnter != null ? mountOnEnter : rest.mountOnEnter,
		unmountOnExit: unmountOnExit != null ? unmountOnExit : rest.unmountOnExit,
		onEnter,
		onEntering,
		onEntered,
		onExit,
		onExiting,
		onExited
	}];
}
var TabPanel = /* @__PURE__ */ import_react.forwardRef((_ref2, ref) => {
	let { as: Component = "div" } = _ref2, props = _objectWithoutPropertiesLoose(_ref2, _excluded3);
	const [tabPanelProps, { isActive, onEnter, onEntering, onEntered, onExit, onExiting, onExited, mountOnEnter, unmountOnExit, transition: Transition = NoopTransition_default }] = useTabPanel(props);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TabContext_default.Provider, {
		value: null,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SelectableContext_default.Provider, {
			value: null,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Transition, {
				in: isActive,
				onEnter,
				onEntering,
				onEntered,
				onExit,
				onExiting,
				onExited,
				mountOnEnter,
				unmountOnExit,
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, Object.assign({}, tabPanelProps, {
					ref,
					hidden: !isActive,
					"aria-hidden": !isActive
				}))
			})
		})
	});
});
TabPanel.displayName = "TabPanel";
var TabPanel_default = TabPanel;

//#endregion
//#region node_modules/@restart/ui/esm/Tabs.js
var Tabs$1 = (props) => {
	const { id: userId, generateChildId: generateCustomChildId, onSelect: propsOnSelect, activeKey: propsActiveKey, defaultActiveKey, transition, mountOnEnter, unmountOnExit, children } = props;
	const [activeKey, onSelect] = useUncontrolledProp(propsActiveKey, defaultActiveKey, propsOnSelect);
	const id = $b5e257d569688ac6$export$619500959fc48b26(userId);
	const generateChildId = (0, import_react.useMemo)(() => generateCustomChildId || ((key, type) => id ? `${id}-${type}-${key}` : null), [id, generateCustomChildId]);
	const tabContext = (0, import_react.useMemo)(() => ({
		onSelect,
		activeKey,
		transition,
		mountOnEnter: mountOnEnter || false,
		unmountOnExit: unmountOnExit || false,
		getControlledId: (key) => generateChildId(key, "tabpane"),
		getControllerId: (key) => generateChildId(key, "tab")
	}), [
		onSelect,
		activeKey,
		transition,
		mountOnEnter,
		unmountOnExit,
		generateChildId
	]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TabContext_default.Provider, {
		value: tabContext,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SelectableContext_default.Provider, {
			value: onSelect || null,
			children
		})
	});
};
Tabs$1.Panel = TabPanel_default;
var Tabs_default$1 = Tabs$1;

//#endregion
//#region node_modules/react-bootstrap/esm/getTabTransitionComponent.js
function getTabTransitionComponent(transition) {
	if (typeof transition === "boolean") return transition ? Fade_default : NoopTransition_default;
	return transition;
}

//#endregion
//#region node_modules/react-bootstrap/esm/TabContainer.js
var TabContainer = ({ transition,...props }) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Tabs_default$1, {
	...props,
	transition: getTabTransitionComponent(transition)
});
TabContainer.displayName = "TabContainer";
var TabContainer_default = TabContainer;

//#endregion
//#region node_modules/react-bootstrap/esm/TabContent.js
var import_classnames$7 = /* @__PURE__ */ __toESM(require_classnames());
var TabContent = /* @__PURE__ */ import_react.forwardRef(({ className, bsPrefix, as: Component = "div",...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "tab-content");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		className: (0, import_classnames$7.default)(className, bsPrefix),
		...props
	});
});
TabContent.displayName = "TabContent";
var TabContent_default = TabContent;

//#endregion
//#region node_modules/react-bootstrap/esm/TabPane.js
var import_classnames$6 = /* @__PURE__ */ __toESM(require_classnames());
var TabPane = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, transition,...props }, ref) => {
	const [{ className, as: Component = "div",...rest }, { isActive, onEnter, onEntering, onEntered, onExit, onExiting, onExited, mountOnEnter, unmountOnExit, transition: Transition = Fade_default }] = useTabPanel({
		...props,
		transition: getTabTransitionComponent(transition)
	});
	const prefix = useBootstrapPrefix(bsPrefix, "tab-pane");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TabContext_default.Provider, {
		value: null,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SelectableContext_default.Provider, {
			value: null,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Transition, {
				in: isActive,
				onEnter,
				onEntering,
				onEntered,
				onExit,
				onExiting,
				onExited,
				mountOnEnter,
				unmountOnExit,
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
					...rest,
					ref,
					className: (0, import_classnames$6.default)(className, prefix, isActive && "active")
				})
			})
		})
	});
});
TabPane.displayName = "TabPane";
var TabPane_default = TabPane;

//#endregion
//#region node_modules/react-bootstrap/esm/Tab.js
var import_prop_types = /* @__PURE__ */ __toESM(require_prop_types());
var propTypes = {
	eventKey: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.number]),
	title: import_prop_types.default.node.isRequired,
	disabled: import_prop_types.default.bool,
	tabClassName: import_prop_types.default.string,
	tabAttrs: import_prop_types.default.object
};
var Tab = () => {
	throw new Error("ReactBootstrap: The `Tab` component is not meant to be rendered! It's an abstract component that is only valid as a direct Child of the `Tabs` Component. For custom tabs components use TabPane and TabsContainer directly");
};
Tab.propTypes = propTypes;
var Tab_default = Object.assign(Tab, {
	Container: TabContainer_default,
	Content: TabContent_default,
	Pane: TabPane_default
});

//#endregion
//#region node_modules/react-bootstrap/esm/Table.js
var import_classnames$5 = /* @__PURE__ */ __toESM(require_classnames());
var Table = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, className, striped, bordered, borderless, hover, size: size$1, variant, responsive,...props }, ref) => {
	const decoratedBsPrefix = useBootstrapPrefix(bsPrefix, "table");
	const classes = (0, import_classnames$5.default)(className, decoratedBsPrefix, variant && `${decoratedBsPrefix}-${variant}`, size$1 && `${decoratedBsPrefix}-${size$1}`, striped && `${decoratedBsPrefix}-${typeof striped === "string" ? `striped-${striped}` : "striped"}`, bordered && `${decoratedBsPrefix}-bordered`, borderless && `${decoratedBsPrefix}-borderless`, hover && `${decoratedBsPrefix}-hover`);
	const table = /* @__PURE__ */ (0, import_jsx_runtime.jsx)("table", {
		...props,
		className: classes,
		ref
	});
	if (responsive) {
		let responsiveClass = `${decoratedBsPrefix}-responsive`;
		if (typeof responsive === "string") responsiveClass = `${responsiveClass}-${responsive}`;
		return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: responsiveClass,
			children: table
		});
	}
	return table;
});
Table.displayName = "Table";
var Table_default = Table;

//#endregion
//#region node_modules/react-bootstrap/esm/Tabs.js
function getDefaultActiveKey(children) {
	let defaultActiveKey;
	forEach(children, (child) => {
		if (defaultActiveKey == null) defaultActiveKey = child.props.eventKey;
	});
	return defaultActiveKey;
}
function renderTab(child) {
	const { title, eventKey, disabled, tabClassName, tabAttrs, id } = child.props;
	if (title == null) return null;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(NavItem_default, {
		as: "li",
		role: "presentation",
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(NavLink_default, {
			as: "button",
			type: "button",
			eventKey,
			disabled,
			id,
			className: tabClassName,
			...tabAttrs,
			children: title
		})
	});
}
var Tabs = (props) => {
	const { id, onSelect, transition, mountOnEnter = false, unmountOnExit = false, variant = "tabs", children, activeKey = getDefaultActiveKey(children),...controlledProps } = useUncontrolled(props, { activeKey: "onSelect" });
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Tabs_default$1, {
		id,
		activeKey,
		onSelect,
		transition: getTabTransitionComponent(transition),
		mountOnEnter,
		unmountOnExit,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Nav_default, {
			id,
			...controlledProps,
			role: "tablist",
			as: "ul",
			variant,
			children: map(children, renderTab)
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TabContent_default, { children: map(children, (child) => {
			const childProps = { ...child.props };
			delete childProps.title;
			delete childProps.disabled;
			delete childProps.tabClassName;
			delete childProps.tabAttrs;
			return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TabPane_default, { ...childProps });
		}) })]
	});
};
Tabs.displayName = "Tabs";
var Tabs_default = Tabs;

//#endregion
//#region node_modules/react-bootstrap/esm/ToastFade.js
var fadeStyles = {
	[ENTERING]: "showing",
	[EXITING]: "showing show"
};
var ToastFade = /* @__PURE__ */ import_react.forwardRef((props, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Fade_default, {
	...props,
	ref,
	transitionClasses: fadeStyles
}));
ToastFade.displayName = "ToastFade";
var ToastFade_default = ToastFade;

//#endregion
//#region node_modules/react-bootstrap/esm/ToastContext.js
var ToastContext = /* @__PURE__ */ import_react.createContext({ onClose() {} });
var ToastContext_default = ToastContext;

//#endregion
//#region node_modules/react-bootstrap/esm/ToastHeader.js
var import_classnames$4 = /* @__PURE__ */ __toESM(require_classnames());
var ToastHeader = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, closeLabel = "Close", closeVariant, closeButton = true, className, children,...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "toast-header");
	const context$3 = (0, import_react.useContext)(ToastContext_default);
	const handleClick = useEventCallback((e) => {
		context$3 == null || context$3.onClose == null || context$3.onClose(e);
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		ref,
		...props,
		className: (0, import_classnames$4.default)(bsPrefix, className),
		children: [children, closeButton && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CloseButton_default, {
			"aria-label": closeLabel,
			variant: closeVariant,
			onClick: handleClick,
			"data-dismiss": "toast"
		})]
	});
});
ToastHeader.displayName = "ToastHeader";
var ToastHeader_default = ToastHeader;

//#endregion
//#region node_modules/react-bootstrap/esm/ToastBody.js
var import_classnames$3 = /* @__PURE__ */ __toESM(require_classnames());
var ToastBody = /* @__PURE__ */ import_react.forwardRef(({ className, bsPrefix, as: Component = "div",...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "toast-body");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		className: (0, import_classnames$3.default)(className, bsPrefix),
		...props
	});
});
ToastBody.displayName = "ToastBody";
var ToastBody_default = ToastBody;

//#endregion
//#region node_modules/react-bootstrap/esm/Toast.js
var import_classnames$2 = /* @__PURE__ */ __toESM(require_classnames());
var Toast = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, className, transition: Transition = ToastFade_default, show = true, animation = true, delay = 5e3, autohide = false, onClose, onEntered, onExit, onExiting, onEnter, onEntering, onExited, bg,...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "toast");
	const delayRef = (0, import_react.useRef)(delay);
	const onCloseRef = (0, import_react.useRef)(onClose);
	(0, import_react.useEffect)(() => {
		delayRef.current = delay;
		onCloseRef.current = onClose;
	}, [delay, onClose]);
	const autohideTimeout = useTimeout();
	const autohideToast = !!(autohide && show);
	const autohideFunc = (0, import_react.useCallback)(() => {
		if (autohideToast) onCloseRef.current == null || onCloseRef.current();
	}, [autohideToast]);
	(0, import_react.useEffect)(() => {
		autohideTimeout.set(autohideFunc, delayRef.current);
	}, [autohideTimeout, autohideFunc]);
	const toastContext = (0, import_react.useMemo)(() => ({ onClose }), [onClose]);
	const hasAnimation = !!(Transition && animation);
	const toast = /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		...props,
		ref,
		className: (0, import_classnames$2.default)(bsPrefix, className, bg && `bg-${bg}`, !hasAnimation && (show ? "show" : "hide")),
		role: "alert",
		"aria-live": "assertive",
		"aria-atomic": "true"
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ToastContext_default.Provider, {
		value: toastContext,
		children: hasAnimation && Transition ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Transition, {
			in: show,
			onEnter,
			onEntering,
			onEntered,
			onExit,
			onExiting,
			onExited,
			unmountOnExit: true,
			children: toast
		}) : toast
	});
});
Toast.displayName = "Toast";
var Toast_default = Object.assign(Toast, {
	Body: ToastBody_default,
	Header: ToastHeader_default
});

//#endregion
//#region node_modules/react-bootstrap/esm/ToastContainer.js
var import_classnames$1 = /* @__PURE__ */ __toESM(require_classnames());
var positionClasses = {
	"top-start": "top-0 start-0",
	"top-center": "top-0 start-50 translate-middle-x",
	"top-end": "top-0 end-0",
	"middle-start": "top-50 start-0 translate-middle-y",
	"middle-center": "top-50 start-50 translate-middle",
	"middle-end": "top-50 end-0 translate-middle-y",
	"bottom-start": "bottom-0 start-0",
	"bottom-center": "bottom-0 start-50 translate-middle-x",
	"bottom-end": "bottom-0 end-0"
};
var ToastContainer = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, position, containerPosition, className, as: Component = "div",...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "toast-container");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		...props,
		className: (0, import_classnames$1.default)(bsPrefix, position && positionClasses[position], containerPosition && `position-${containerPosition}`, className)
	});
});
ToastContainer.displayName = "ToastContainer";
var ToastContainer_default = ToastContainer;

//#endregion
//#region node_modules/react-bootstrap/esm/ToggleButton.js
var import_classnames = /* @__PURE__ */ __toESM(require_classnames());
var noop = () => void 0;
var ToggleButton = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, name, className, checked, type, onChange, value, disabled, id, inputRef,...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "btn-check");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("input", {
		className: bsPrefix,
		name,
		type,
		value,
		ref: inputRef,
		autoComplete: "off",
		checked: !!checked,
		disabled: !!disabled,
		onChange: onChange || noop,
		id
	}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Button_default, {
		...props,
		ref,
		className: (0, import_classnames.default)(className, disabled && "disabled"),
		type: void 0,
		role: void 0,
		as: "label",
		htmlFor: id
	})] });
});
ToggleButton.displayName = "ToggleButton";
var ToggleButton_default = ToggleButton;

//#endregion
//#region node_modules/react-bootstrap/esm/ToggleButtonGroup.js
var import_browser = /* @__PURE__ */ __toESM(require_browser());
var ToggleButtonGroup = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	const { children, type = "radio", name, value, onChange, vertical = false,...controlledProps } = useUncontrolled(props, { value: "onChange" });
	const getValues = () => value == null ? [] : [].concat(value);
	const handleToggle = (inputVal, event) => {
		if (!onChange) return;
		const values = getValues();
		const isActive = values.indexOf(inputVal) !== -1;
		if (type === "radio") {
			if (!isActive) onChange(inputVal, event);
			return;
		}
		if (isActive) onChange(values.filter((n) => n !== inputVal), event);
		else onChange([...values, inputVal], event);
	};
	!(type !== "radio" || !!name) && (0, import_browser.default)(false, "A `name` is required to group the toggle buttons when the `type` is set to \"radio\"");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ButtonGroup_default, {
		...controlledProps,
		ref,
		vertical,
		children: map(children, (child) => {
			const values = getValues();
			const { value: childVal, onChange: childOnChange } = child.props;
			const handler = (e) => handleToggle(childVal, e);
			return /* @__PURE__ */ import_react.cloneElement(child, {
				type,
				name: child.name || name,
				checked: values.indexOf(childVal) !== -1,
				onChange: createChainedFunction_default(childOnChange, handler)
			});
		})
	});
});
ToggleButtonGroup.displayName = "ToggleButtonGroup";
var ToggleButtonGroup_default = Object.assign(ToggleButtonGroup, { Button: ToggleButton_default });

//#endregion
export { Accordion_default as Accordion, AccordionBody_default as AccordionBody, AccordionButton_default as AccordionButton, AccordionCollapse_default as AccordionCollapse, AccordionContext_default as AccordionContext, AccordionHeader_default as AccordionHeader, AccordionItem_default as AccordionItem, Alert_default as Alert, AlertHeading_default as AlertHeading, AlertLink_default as AlertLink, Anchor_default as Anchor, Badge_default as Badge, Breadcrumb_default as Breadcrumb, BreadcrumbItem_default as BreadcrumbItem, Button_default as Button, ButtonGroup_default as ButtonGroup, ButtonToolbar_default as ButtonToolbar, Card_default as Card, CardBody_default as CardBody, CardFooter_default as CardFooter, CardGroup_default as CardGroup, CardHeader_default as CardHeader, CardImg_default as CardImg, CardImgOverlay_default as CardImgOverlay, CardLink_default as CardLink, CardSubtitle_default as CardSubtitle, CardText_default as CardText, CardTitle_default as CardTitle, Carousel_default as Carousel, CarouselCaption_default as CarouselCaption, CarouselItem_default as CarouselItem, CloseButton_default as CloseButton, Col_default as Col, Collapse_default as Collapse, Container_default as Container, Dropdown_default as Dropdown, DropdownButton_default as DropdownButton, DropdownDivider_default as DropdownDivider, DropdownHeader_default as DropdownHeader, DropdownItem_default as DropdownItem, DropdownItemText_default as DropdownItemText, DropdownMenu_default as DropdownMenu, DropdownToggle_default as DropdownToggle, Fade_default as Fade, Figure_default as Figure, FigureCaption_default as FigureCaption, FigureImage_default as FigureImage, FloatingLabel_default as FloatingLabel, Form_default as Form, FormCheck_default as FormCheck, FormControl_default as FormControl, FormFloating_default as FormFloating, FormGroup_default as FormGroup, FormLabel_default as FormLabel, FormSelect_default as FormSelect, FormText_default as FormText, Image_default as Image, InputGroup_default as InputGroup, ListGroup_default as ListGroup, ListGroupItem_default as ListGroupItem, Modal_default as Modal, ModalBody_default as ModalBody, ModalDialog_default as ModalDialog, ModalFooter_default as ModalFooter, ModalHeader_default as ModalHeader, ModalTitle_default as ModalTitle, Nav_default as Nav, NavDropdown_default as NavDropdown, NavItem_default as NavItem, NavLink_default as NavLink, Navbar_default as Navbar, NavbarBrand_default as NavbarBrand, NavbarCollapse_default as NavbarCollapse, NavbarOffcanvas_default as NavbarOffcanvas, NavbarText_default as NavbarText, NavbarToggle_default as NavbarToggle, Offcanvas_default as Offcanvas, OffcanvasBody_default as OffcanvasBody, OffcanvasHeader_default as OffcanvasHeader, OffcanvasTitle_default as OffcanvasTitle, OffcanvasToggling_default as OffcanvasToggling, Overlay_default as Overlay, OverlayTrigger_default as OverlayTrigger, PageItem_default as PageItem, Pagination_default as Pagination, Placeholder_default as Placeholder, PlaceholderButton_default as PlaceholderButton, Popover_default as Popover, PopoverBody_default as PopoverBody, PopoverHeader_default as PopoverHeader, ProgressBar_default as ProgressBar, Ratio_default as Ratio, Row_default as Row, SSRProvider_default as SSRProvider, Spinner_default as Spinner, SplitButton_default as SplitButton, Stack_default as Stack, Tab_default as Tab, TabContainer_default as TabContainer, TabContent_default as TabContent, TabPane_default as TabPane, Table_default as Table, Tabs_default as Tabs, ThemeProvider_default as ThemeProvider, Toast_default as Toast, ToastBody_default as ToastBody, ToastContainer_default as ToastContainer, ToastHeader_default as ToastHeader, ToggleButton_default as ToggleButton, ToggleButtonGroup_default as ToggleButtonGroup, Tooltip_default as Tooltip, useAccordionButton };
//# sourceMappingURL=react-bootstrap.js.map