import { __commonJS, __toESM, require_react } from "./react-BaqBjuxQ.js";

//#region node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
	return _extends = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
		}
		return n;
	}, _extends.apply(null, arguments);
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(r, e) {
	if (null == r) return {};
	var t = {};
	for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r[n];
	}
	return t;
}

//#endregion
//#region node_modules/invariant/browser.js
var require_browser = /* @__PURE__ */ __commonJS({ "node_modules/invariant/browser.js": ((exports, module) => {
	/**
	* Use invariant() to assert state which your program assumes to be true.
	*
	* Provide sprintf-style format (only %s is supported) and arguments
	* to provide information about what broke and what you were
	* expecting.
	*
	* The invariant message will be stripped in production, but the invariant
	* will remain to ensure logic does not differ in production.
	*/
	var invariant$2 = function(condition, format, a, b, c, d, e, f) {
		if (format === void 0) throw new Error("invariant requires an error message argument");
		if (!condition) {
			var error;
			if (format === void 0) error = /* @__PURE__ */ new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
			else {
				var args = [
					a,
					b,
					c,
					d,
					e,
					f
				];
				var argIndex = 0;
				error = new Error(format.replace(/%s/g, function() {
					return args[argIndex++];
				}));
				error.name = "Invariant Violation";
			}
			error.framesToPop = 1;
			throw error;
		}
	};
	module.exports = invariant$2;
}) });

//#endregion
//#region node_modules/uncontrollable/lib/esm/utils.js
var import_browser$1 = /* @__PURE__ */ __toESM(require_browser());
function defaultKey(key) {
	return "default" + key.charAt(0).toUpperCase() + key.substr(1);
}

//#endregion
//#region node_modules/uncontrollable/lib/esm/hook.js
var import_react = /* @__PURE__ */ __toESM(require_react());
function _toPropertyKey(arg) {
	var key = _toPrimitive(arg, "string");
	return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
	if (typeof input !== "object" || input === null) return input;
	var prim = input[Symbol.toPrimitive];
	if (prim !== void 0) {
		var res = prim.call(input, hint || "default");
		if (typeof res !== "object") return res;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return (hint === "string" ? String : Number)(input);
}
function useUncontrolledProp(propValue, defaultValue, handler) {
	var wasPropRef = (0, import_react.useRef)(propValue !== void 0);
	var _useState = (0, import_react.useState)(defaultValue), stateValue = _useState[0], setState = _useState[1];
	var isProp = propValue !== void 0;
	var wasProp = wasPropRef.current;
	wasPropRef.current = isProp;
	/**
	* If a prop switches from controlled to Uncontrolled
	* reset its value to the defaultValue
	*/
	if (!isProp && wasProp && stateValue !== defaultValue) setState(defaultValue);
	return [isProp ? propValue : stateValue, (0, import_react.useCallback)(function(value) {
		for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
		if (handler) handler.apply(void 0, [value].concat(args));
		setState(value);
	}, [handler])];
}
function useUncontrolled(props, config) {
	return Object.keys(config).reduce(function(result, fieldName) {
		var _extends2;
		var _ref = result, defaultValue = _ref[defaultKey(fieldName)], propsValue = _ref[fieldName], rest = _objectWithoutPropertiesLoose(_ref, [defaultKey(fieldName), fieldName].map(_toPropertyKey));
		var handlerName = config[fieldName];
		var _useUncontrolledProp = useUncontrolledProp(propsValue, defaultValue, props[handlerName]), value = _useUncontrolledProp[0], handler = _useUncontrolledProp[1];
		return _extends({}, rest, (_extends2 = {}, _extends2[fieldName] = value, _extends2[handlerName] = handler, _extends2));
	}, props);
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(t, e) {
	return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t$1, e$1) {
		return t$1.__proto__ = e$1, t$1;
	}, _setPrototypeOf(t, e);
}

//#endregion
//#region node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose(t, o) {
	t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);
}

//#endregion
//#region node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js
/**
* Copyright (c) 2013-present, Facebook, Inc.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
function componentWillMount() {
	var state = this.constructor.getDerivedStateFromProps(this.props, this.state);
	if (state !== null && state !== void 0) this.setState(state);
}
function componentWillReceiveProps(nextProps) {
	function updater(prevState) {
		var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);
		return state !== null && state !== void 0 ? state : null;
	}
	this.setState(updater.bind(this));
}
function componentWillUpdate(nextProps, nextState) {
	try {
		var prevProps = this.props;
		var prevState = this.state;
		this.props = nextProps;
		this.state = nextState;
		this.__reactInternalSnapshotFlag = true;
		this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(prevProps, prevState);
	} finally {
		this.props = prevProps;
		this.state = prevState;
	}
}
componentWillMount.__suppressDeprecationWarning = true;
componentWillReceiveProps.__suppressDeprecationWarning = true;
componentWillUpdate.__suppressDeprecationWarning = true;

//#endregion
//#region node_modules/uncontrollable/lib/esm/uncontrollable.js
var import_browser = /* @__PURE__ */ __toESM(require_browser());

//#endregion
//#region node_modules/@restart/ui/node_modules/@restart/hooks/esm/useCommittedRef.js
/**
* Creates a `Ref` whose value is updated in an effect, ensuring the most recent
* value is the one rendered with. Generally only required for Concurrent mode usage
* where previous work in `render()` may be discarded before being used.
*
* This is safe to access in an event handler.
*
* @param value The `Ref` value
*/
function useCommittedRef(value) {
	const ref = (0, import_react.useRef)(value);
	(0, import_react.useEffect)(() => {
		ref.current = value;
	}, [value]);
	return ref;
}
var useCommittedRef_default = useCommittedRef;

//#endregion
//#region node_modules/@restart/ui/node_modules/@restart/hooks/esm/useEventCallback.js
function useEventCallback(fn) {
	const ref = useCommittedRef_default(fn);
	return (0, import_react.useCallback)(function(...args) {
		return ref.current && ref.current(...args);
	}, [ref]);
}

//#endregion
//#region node_modules/@restart/ui/node_modules/@restart/hooks/esm/useMounted.js
/**
* Track whether a component is current mounted. Generally less preferable than
* properlly canceling effects so they don't run after a component is unmounted,
* but helpful in cases where that isn't feasible, such as a `Promise` resolution.
*
* @returns a function that returns the current isMounted state of the component
*
* ```ts
* const [data, setData] = useState(null)
* const isMounted = useMounted()
*
* useEffect(() => {
*   fetchdata().then((newData) => {
*      if (isMounted()) {
*        setData(newData);
*      }
*   })
* })
* ```
*/
function useMounted() {
	const mounted = (0, import_react.useRef)(true);
	const isMounted = (0, import_react.useRef)(() => mounted.current);
	(0, import_react.useEffect)(() => {
		mounted.current = true;
		return () => {
			mounted.current = false;
		};
	}, []);
	return isMounted.current;
}

//#endregion
//#region node_modules/@restart/ui/node_modules/@restart/hooks/esm/usePrevious.js
/**
* Store the last of some value. Tracked via a `Ref` only updating it
* after the component renders.
*
* Helpful if you need to compare a prop value to it's previous value during render.
*
* ```ts
* function Component(props) {
*   const lastProps = usePrevious(props)
*
*   if (lastProps.foo !== props.foo)
*     resetValueFromProps(props.foo)
* }
* ```
*
* @param value the value to track
*/
function usePrevious(value) {
	const ref = (0, import_react.useRef)(null);
	(0, import_react.useEffect)(() => {
		ref.current = value;
	});
	return ref.current;
}

//#endregion
//#region node_modules/@restart/ui/node_modules/@restart/hooks/esm/useIsomorphicEffect.js
var isReactNative = typeof global !== "undefined" && global.navigator && global.navigator.product === "ReactNative";
var isDOM = typeof document !== "undefined";
/**
* Is `useLayoutEffect` in a DOM or React Native environment, otherwise resolves to useEffect
* Only useful to avoid the console warning.
*
* PREFER `useEffect` UNLESS YOU KNOW WHAT YOU ARE DOING.
*
* @category effects
*/
var useIsomorphicEffect_default = isDOM || isReactNative ? import_react.useLayoutEffect : import_react.useEffect;

//#endregion
//#region node_modules/dom-helpers/esm/querySelectorAll.js
var toArray = Function.prototype.bind.call(Function.prototype.call, [].slice);
/**
* Runs `querySelectorAll` on a given element.
* 
* @param element the element
* @param selector the selector
*/
function qsa(element, selector) {
	return toArray(element.querySelectorAll(selector));
}

//#endregion
//#region node_modules/@restart/ui/esm/SelectableContext.js
var SelectableContext = /* @__PURE__ */ import_react.createContext(null);
const makeEventKey = (eventKey, href = null) => {
	if (eventKey != null) return String(eventKey);
	return href || null;
};
var SelectableContext_default = SelectableContext;

//#endregion
//#region node_modules/@restart/ui/esm/DataKey.js
const ATTRIBUTE_PREFIX = `data-rr-ui-`;
const PROPERTY_PREFIX = `rrUi`;
function dataAttr(property) {
	return `${ATTRIBUTE_PREFIX}${property}`;
}
function dataProp(property) {
	return `${PROPERTY_PREFIX}${property}`;
}

//#endregion
//#region node_modules/react-bootstrap/esm/NavbarContext.js
var context = /* @__PURE__ */ import_react.createContext(null);
context.displayName = "NavbarContext";
var NavbarContext_default = context;

//#endregion
//#region node_modules/@restart/ui/node_modules/@restart/hooks/esm/useMergedRefs.js
var toFnRef = (ref) => !ref || typeof ref === "function" ? ref : (value) => {
	ref.current = value;
};
function mergeRefs(refA, refB) {
	const a = toFnRef(refA);
	const b = toFnRef(refB);
	return (value) => {
		if (a) a(value);
		if (b) b(value);
	};
}
/**
* Create and returns a single callback ref composed from two other Refs.
*
* ```tsx
* const Button = React.forwardRef((props, ref) => {
*   const [element, attachRef] = useCallbackRef<HTMLButtonElement>();
*   const mergedRef = useMergedRefs(ref, attachRef);
*
*   return <button ref={mergedRef} {...props}/>
* })
* ```
*
* @param refA A Callback or mutable Ref
* @param refB A Callback or mutable Ref
* @category refs
*/
function useMergedRefs(refA, refB) {
	return (0, import_react.useMemo)(() => mergeRefs(refA, refB), [refA, refB]);
}
var useMergedRefs_default = useMergedRefs;

//#endregion
export { NavbarContext_default, SelectableContext_default, _inheritsLoose, _objectWithoutPropertiesLoose, dataAttr, dataProp, makeEventKey, qsa, require_browser, useEventCallback, useIsomorphicEffect_default, useMergedRefs_default, useMounted, usePrevious, useUncontrolled, useUncontrolledProp };
//# sourceMappingURL=useMergedRefs-DiqteKKP.js.map